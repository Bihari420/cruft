{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Read Latest Documentation - Browse GitHub Code Repository cruft allows you to maintain all the necessary boilerplate for packaging and building projects separate from the code you intentionally write. Fully compatible with existing Cookiecutter templates. Creating new projects from templates using cruft is easy: And, so is updating them as the template changes overtime: Many project template utilities exist that automate the copying and pasting of code to create new projects. This seems great! However, once created, most leave you with that copy-and-pasted code to manage through the life of your project. cruft is different. It automates the creation of new projects like the others, but then it also helps you to manage the boilerplate through the life of the project. cruft makes sure your code stays in-sync with the template it came from for you. Key Features: Cookiecutter Compatible : cruft utilizes Cookiecutter as its template expansion engine. Meaning it retains full compatibility with all existing Cookiecutter templates. Template Validation : cruft can quickly validate whether or not a project is using the latest version of a template using cruft check . This check can easily be added to CI pipelines to ensure your projects stay in-sync. Automatic Template Updates : cruft automates the process of updating code to match the latest version of a template, making it easy to utilize template improvements across many projects. Installation: To get started - install cruft using a Python package manager: pip3 install cruft OR poetry add cruft OR pipenv install cruft Creating a New Project: To create a new project using cruft run cruft create PROJECT_URL from the command line. For example: cruft create https : // github . com / timothycrosley / cookiecutter - python / cruft will then ask you any necessary questions to create your new project. It will use your answers to expand the provided template, and then return the directory it placed the expanded project. Behind the scenes, cruft uses Cookiecutter to do the project expansion. The only difference in the resulting output is a .cruft.json file that contains the git hash of the template used as well as the parameters specified. Updating a Project To update an existing project, that was created using cruft, run cruft update in the root of the project. If there are any updates, cruft will have you review them before applying. If you accept the changes cruft will apply them to your project and update the .cruft.json file for you. Tip Sometimes certain files just aren't good fits for updating. Such as test cases or __init__ files. You can tell cruft to always skip updating these files on a project by project basis by added them to a skip section within your .cruft.json file: { \"template\" : \"https://github.com/timothycrosley/cookiecutter-python\" , \"commit\" : \"8a65a360d51250221193ed0ec5ed292e72b32b0b\" , \"skip\" : [ \"cruft/__init__.py\" , \"tests\" ], ... } Checking a Project Checking to see if a project is missing a template update is as easy as running cruft check . If the project is out-of-date an error and exit code 1 will be returned. cruft check can be added to CI pipelines to ensure projects don't unintentionally drift. Linking an Existing Project Have an existing project that you created from a template in the past using Cookiecutter directly? You can link it to the template that was used to create it using: cruft link TEMPLATE_REPOSITORY . For example: cruft link https : // github . com / timothycrosley / cookiecutter - python / You can then specify the last commit of the template the project has been updated to be consistent with, or accept the default of using the latest commit from the template. Why Create cruft? Since I first saw videos of quickly being used to automate Ubuntu application creation, I've had a love/hate relationship with these kinds of tools. I've used them for many projects and certainly seen them lead to productivity improvements. However, I've always felt like they were a double-edged sword. Sure, they would automate away the copying and pasting many would do to create projects. However, by doing so, they encouraged more code to be copied and pasted! Then, over time, you could easily be left with hundreds of projects that contained copy-and-pasted code with no way to easy way to update them. I created cruft to be a tool that recognized that balance between project creation and maintenance and provided mechanisms to keep built projects up-to-date. I hope you too find cruft useful! ~Timothy Crosley","title":"Home"},{"location":"#key-features","text":"Cookiecutter Compatible : cruft utilizes Cookiecutter as its template expansion engine. Meaning it retains full compatibility with all existing Cookiecutter templates. Template Validation : cruft can quickly validate whether or not a project is using the latest version of a template using cruft check . This check can easily be added to CI pipelines to ensure your projects stay in-sync. Automatic Template Updates : cruft automates the process of updating code to match the latest version of a template, making it easy to utilize template improvements across many projects.","title":"Key Features:"},{"location":"#installation","text":"To get started - install cruft using a Python package manager: pip3 install cruft OR poetry add cruft OR pipenv install cruft","title":"Installation:"},{"location":"#creating-a-new-project","text":"To create a new project using cruft run cruft create PROJECT_URL from the command line. For example: cruft create https : // github . com / timothycrosley / cookiecutter - python / cruft will then ask you any necessary questions to create your new project. It will use your answers to expand the provided template, and then return the directory it placed the expanded project. Behind the scenes, cruft uses Cookiecutter to do the project expansion. The only difference in the resulting output is a .cruft.json file that contains the git hash of the template used as well as the parameters specified.","title":"Creating a New Project:"},{"location":"#updating-a-project","text":"To update an existing project, that was created using cruft, run cruft update in the root of the project. If there are any updates, cruft will have you review them before applying. If you accept the changes cruft will apply them to your project and update the .cruft.json file for you. Tip Sometimes certain files just aren't good fits for updating. Such as test cases or __init__ files. You can tell cruft to always skip updating these files on a project by project basis by added them to a skip section within your .cruft.json file: { \"template\" : \"https://github.com/timothycrosley/cookiecutter-python\" , \"commit\" : \"8a65a360d51250221193ed0ec5ed292e72b32b0b\" , \"skip\" : [ \"cruft/__init__.py\" , \"tests\" ], ... }","title":"Updating a Project"},{"location":"#checking-a-project","text":"Checking to see if a project is missing a template update is as easy as running cruft check . If the project is out-of-date an error and exit code 1 will be returned. cruft check can be added to CI pipelines to ensure projects don't unintentionally drift.","title":"Checking a Project"},{"location":"#linking-an-existing-project","text":"Have an existing project that you created from a template in the past using Cookiecutter directly? You can link it to the template that was used to create it using: cruft link TEMPLATE_REPOSITORY . For example: cruft link https : // github . com / timothycrosley / cookiecutter - python / You can then specify the last commit of the template the project has been updated to be consistent with, or accept the default of using the latest commit from the template.","title":"Linking an Existing Project"},{"location":"#why-create-cruft","text":"Since I first saw videos of quickly being used to automate Ubuntu application creation, I've had a love/hate relationship with these kinds of tools. I've used them for many projects and certainly seen them lead to productivity improvements. However, I've always felt like they were a double-edged sword. Sure, they would automate away the copying and pasting many would do to create projects. However, by doing so, they encouraged more code to be copied and pasted! Then, over time, you could easily be left with hundreds of projects that contained copy-and-pasted code with no way to easy way to update them. I created cruft to be a tool that recognized that balance between project creation and maintenance and provided mechanisms to keep built projects up-to-date. I hope you too find cruft useful! ~Timothy Crosley","title":"Why Create cruft?"},{"location":"CHANGELOG/","text":"Install the latest To install the latest version of cruft simply run: pip3 install cruft OR poetry add cruft OR pipenv install cruft Changelog 1.1.0 - 24 September 2019 Added link command to link existing repositories to the Cookiecutter template that created them. Added skip option to .cruft.json file allowing template updates to be skipped per a repository. Improved patch applying from template updates. Added an interactive option on the update command to skip an individual update, while marking a repository as up-to-date. 1.0.0 - 23 September 2019 Initial API stable release.","title":"Changelog"},{"location":"CHANGELOG/#install-the-latest","text":"To install the latest version of cruft simply run: pip3 install cruft OR poetry add cruft OR pipenv install cruft","title":"Install the latest"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#110-24-september-2019","text":"Added link command to link existing repositories to the Cookiecutter template that created them. Added skip option to .cruft.json file allowing template updates to be skipped per a repository. Improved patch applying from template updates. Added an interactive option on the update command to skip an individual update, while marking a repository as up-to-date.","title":"1.1.0 - 24 September 2019"},{"location":"CHANGELOG/#100-23-september-2019","text":"Initial API stable release.","title":"1.0.0 - 23 September 2019"},{"location":"docs/contributing/1.-contributing-guide/","text":"Contributing to cruft Looking for a useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Welcome! You have found the right place. Getting cruft set up for local development The first step when contributing to any project is getting it set up on your local machine. cruft aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.6+ poetry bash or a bash compatible shell (should be auto-installed on Linux / Mac) Once you have verified that you system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/cruft.git `cd cruft poetry install Making a contribution Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. If you're not sure if it's something that is good for the main cruft project and want immediate feedback, you can discuss it here . Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Ensure your code matches the HOPE-8 Coding Standard used by the project. Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the acknowledgments list :). Thank you! I can not tell you how thankful I am for the hard work done by cruft contributors like you . Thank you! ~Timothy Crosley","title":"1. Contributing Guide"},{"location":"docs/contributing/1.-contributing-guide/#contributing-to-cruft","text":"Looking for a useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Welcome! You have found the right place.","title":"Contributing to cruft"},{"location":"docs/contributing/1.-contributing-guide/#getting-cruft-set-up-for-local-development","text":"The first step when contributing to any project is getting it set up on your local machine. cruft aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.6+ poetry bash or a bash compatible shell (should be auto-installed on Linux / Mac) Once you have verified that you system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/cruft.git `cd cruft poetry install","title":"Getting cruft set up for local development"},{"location":"docs/contributing/1.-contributing-guide/#making-a-contribution","text":"Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. If you're not sure if it's something that is good for the main cruft project and want immediate feedback, you can discuss it here . Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Ensure your code matches the HOPE-8 Coding Standard used by the project. Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the acknowledgments list :).","title":"Making a contribution"},{"location":"docs/contributing/1.-contributing-guide/#thank-you","text":"I can not tell you how thankful I am for the hard work done by cruft contributors like you . Thank you! ~Timothy Crosley","title":"Thank you!"},{"location":"docs/contributing/2.-coding-standard/","text":"HOPE 8 -- Style Guide for Hug Code HOPE: 8 Title: Style Guide for Hug Code Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 19-May-2019 Updated: 17-August-2019 Introduction This document gives coding conventions for the Hug code comprising the Hug core as well as all official interfaces, extensions, and plugins for the framework. Optionally, projects that use Hug are encouraged to follow this HOPE and link to it as a reference. PEP 8 Foundation All guidelines in this document are in addition to those defined in Python's PEP 8 and PEP 257 guidelines. Line Length Too short of lines discourage descriptive variable names where they otherwise make sense. Too long of lines reduce overall readability and make it hard to compare 2 files side by side. There is no perfect number: but for Hug, we've decided to cap the lines at 100 characters. Descriptive Variable names Naming things is hard. Hug has a few strict guidelines on the usage of variable names, which hopefully will reduce some of the guesswork: - No one character variable names. - Except for x, y, and z as coordinates. - It's not okay to override built-in functions. - Except for id . Guido himself thought that shouldn't have been moved to the system module. It's too commonly used, and alternatives feel very artificial. - Avoid Acronyms, Abbreviations, or any other short forms - unless they are almost universally understand. Adding new modules New modules added to the a project that follows the HOPE-8 standard should all live directly within the base PROJECT_NAME/ directory without nesting. If the modules are meant only for internal use within the project, they should be prefixed with a leading underscore. For example, def _internal_function. Modules should contain a docstring at the top that gives a general explanation of the purpose and then restates the project's use of the MIT license. There should be a tests/test_$MODULE_NAME.py file created to correspond to every new module that contains test coverage for the module. Ideally, tests should be 1:1 (one test object per code object, one test method per code method) to the extent cleanly possible. Automated Code Cleaners All code submitted to Hug should be formatted using Black and isort. Black should be run with the line length set to 100, and isort with Black compatible settings in place. Automated Code Linting All code submitted to hug should run through the following tools: Black and isort verification. Flake8 flake8-bugbear Bandit pep8-naming vulture safety","title":"2. Coding Standard"},{"location":"docs/contributing/2.-coding-standard/#hope-8-style-guide-for-hug-code","text":"HOPE: 8 Title: Style Guide for Hug Code Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 19-May-2019 Updated: 17-August-2019","title":"HOPE 8 -- Style Guide for Hug Code"},{"location":"docs/contributing/2.-coding-standard/#introduction","text":"This document gives coding conventions for the Hug code comprising the Hug core as well as all official interfaces, extensions, and plugins for the framework. Optionally, projects that use Hug are encouraged to follow this HOPE and link to it as a reference.","title":"Introduction"},{"location":"docs/contributing/2.-coding-standard/#pep-8-foundation","text":"All guidelines in this document are in addition to those defined in Python's PEP 8 and PEP 257 guidelines.","title":"PEP 8 Foundation"},{"location":"docs/contributing/2.-coding-standard/#line-length","text":"Too short of lines discourage descriptive variable names where they otherwise make sense. Too long of lines reduce overall readability and make it hard to compare 2 files side by side. There is no perfect number: but for Hug, we've decided to cap the lines at 100 characters.","title":"Line Length"},{"location":"docs/contributing/2.-coding-standard/#descriptive-variable-names","text":"Naming things is hard. Hug has a few strict guidelines on the usage of variable names, which hopefully will reduce some of the guesswork: - No one character variable names. - Except for x, y, and z as coordinates. - It's not okay to override built-in functions. - Except for id . Guido himself thought that shouldn't have been moved to the system module. It's too commonly used, and alternatives feel very artificial. - Avoid Acronyms, Abbreviations, or any other short forms - unless they are almost universally understand.","title":"Descriptive Variable names"},{"location":"docs/contributing/2.-coding-standard/#adding-new-modules","text":"New modules added to the a project that follows the HOPE-8 standard should all live directly within the base PROJECT_NAME/ directory without nesting. If the modules are meant only for internal use within the project, they should be prefixed with a leading underscore. For example, def _internal_function. Modules should contain a docstring at the top that gives a general explanation of the purpose and then restates the project's use of the MIT license. There should be a tests/test_$MODULE_NAME.py file created to correspond to every new module that contains test coverage for the module. Ideally, tests should be 1:1 (one test object per code object, one test method per code method) to the extent cleanly possible.","title":"Adding new modules"},{"location":"docs/contributing/2.-coding-standard/#automated-code-cleaners","text":"All code submitted to Hug should be formatted using Black and isort. Black should be run with the line length set to 100, and isort with Black compatible settings in place.","title":"Automated Code Cleaners"},{"location":"docs/contributing/2.-coding-standard/#automated-code-linting","text":"All code submitted to hug should run through the following tools: Black and isort verification. Flake8 flake8-bugbear Bandit pep8-naming vulture safety","title":"Automated Code Linting"},{"location":"docs/contributing/3.-code-of-conduct/","text":"HOPE 11 -- Code of Conduct HOPE: 11 Title: Code of Conduct Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 17-August-2019 Updated: 17-August-2019 Abstract Defines the Code of Conduct for Hug and all related projects. Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting timothy.crosley@gmail.com . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Confidentiality will be maintained with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the [Contributor Covenant][https://www.contributor-covenant.org], version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"3. Code Of Conduct"},{"location":"docs/contributing/3.-code-of-conduct/#hope-11-code-of-conduct","text":"HOPE: 11 Title: Code of Conduct Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 17-August-2019 Updated: 17-August-2019","title":"HOPE 11 -- Code of Conduct"},{"location":"docs/contributing/3.-code-of-conduct/#abstract","text":"Defines the Code of Conduct for Hug and all related projects.","title":"Abstract"},{"location":"docs/contributing/3.-code-of-conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"docs/contributing/3.-code-of-conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"docs/contributing/3.-code-of-conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"docs/contributing/3.-code-of-conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"docs/contributing/3.-code-of-conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting timothy.crosley@gmail.com . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Confidentiality will be maintained with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"docs/contributing/3.-code-of-conduct/#attribution","text":"This Code of Conduct is adapted from the [Contributor Covenant][https://www.contributor-covenant.org], version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"docs/contributing/4.-acknowledgements/","text":"Contributors Core Developers Timothy Crosley (@timothycrosley) Notable Bug Reporters - Code Contributors - Documenters - A sincere thanks to everyone who helps make cruft into a great Python3 project! ~Timothy Crosley","title":"4. Acknowledgements"},{"location":"docs/contributing/4.-acknowledgements/#contributors","text":"","title":"Contributors"},{"location":"docs/contributing/4.-acknowledgements/#core-developers","text":"Timothy Crosley (@timothycrosley)","title":"Core Developers"},{"location":"docs/contributing/4.-acknowledgements/#notable-bug-reporters","text":"-","title":"Notable Bug Reporters"},{"location":"docs/contributing/4.-acknowledgements/#code-contributors","text":"-","title":"Code Contributors"},{"location":"docs/contributing/4.-acknowledgements/#documenters","text":"- A sincere thanks to everyone who helps make cruft into a great Python3 project! ~Timothy Crosley","title":"Documenters"},{"location":"reference/cruft/","text":"Module cruft cruft Allows you to maintain all the necessary cruft for packaging and building projects separate from the code you intentionally write. Built on-top of, and fully compatible with, CookieCutter. View Source \"\"\"**cruft** Allows you to maintain all the necessary cruft for packaging and building projects separate from the code you intentionally write. Built on-top of, and fully compatible with, CookieCutter. \"\"\" from cruft._version import __version__ Sub-modules cruft.api cruft.cli cruft.exceptions cruft.logo","title":"Index"},{"location":"reference/cruft/#module-cruft","text":"cruft Allows you to maintain all the necessary cruft for packaging and building projects separate from the code you intentionally write. Built on-top of, and fully compatible with, CookieCutter. View Source \"\"\"**cruft** Allows you to maintain all the necessary cruft for packaging and building projects separate from the code you intentionally write. Built on-top of, and fully compatible with, CookieCutter. \"\"\" from cruft._version import __version__","title":"Module cruft"},{"location":"reference/cruft/#sub-modules","text":"cruft.api cruft.cli cruft.exceptions cruft.logo","title":"Sub-modules"},{"location":"reference/cruft/api/","text":"Module cruft.api View Source import json import os import sys from functools import partial from pathlib import Path from shutil import move , rmtree from subprocess import PIPE , run # nosec from tempfile import TemporaryDirectory from typing import Optional from cookiecutter.config import get_user_config from cookiecutter.generate import generate_context , generate_files from cookiecutter.prompt import prompt_for_config from examples import example from git import Repo from cruft.exceptions import ( CruftAlreadyPresent , InvalidCookiecutterRepository , NoCruftFound , UnableToFindCookiecutterTemplate , ) json_dump = partial ( json . dump , ensure_ascii = False , indent = 4 , separators = ( \",\" , \": \" )) @example ( \"https://github.com/timothycrosley/cookiecutter-python/\" , no_input = True ) def create ( template_git_url : str , output_dir : str = \".\" , config_file : Optional [ str ] = None , default_config : bool = False , extra_context : Optional [ dict ] = None , no_input : bool = False , overwrite_if_exists : bool = False , ) -> str : \"\"\"Expand a Git based Cookiecutter template into a new project on disk.\"\"\" with TemporaryDirectory () as cookiecutter_template_dir : try : repo = Repo . clone_from ( template_git_url , cookiecutter_template_dir ) last_commit = repo . head . object . hexsha except Exception as e : raise InvalidCookiecutterRepository ( e ) main_cookiecutter_directory : str = \"\" for file_name in os . listdir ( cookiecutter_template_dir ): file_path = os . path . join ( cookiecutter_template_dir , file_name ) if ( os . path . isdir ( file_path ) and \"{{\" in file_name and \"}}\" in file_name and \"cookiecutter.\" in file_name ): main_cookiecutter_directory = file_path break if not main_cookiecutter_directory : # pragma: no cover raise UnableToFindCookiecutterTemplate ( cookiecutter_template_dir ) context_file = os . path . join ( cookiecutter_template_dir , \"cookiecutter.json\" ) config_dict = get_user_config ( config_file = config_file , default_config = default_config ) context = generate_context ( context_file = context_file , default_context = config_dict [ \"default_context\" ], extra_context = extra_context , ) # prompt the user to manually configure at the command line. # except when 'no-input' flag is set context [ \"cookiecutter\" ] = prompt_for_config ( context , no_input ) context [ \"cookiecutter\" ][ \"_template\" ] = template_git_url with open ( os . path . join ( main_cookiecutter_directory , \".cruft.json\" ), \"w\" ) as cruft_file : json_dump ( { \"template\" : template_git_url , \"commit\" : last_commit , \"context\" : context }, cruft_file , ) return generate_files ( repo_dir = cookiecutter_template_dir , context = context , overwrite_if_exists = overwrite_if_exists , output_dir = output_dir , ) @example () def check ( expanded_dir : str = \".\" ) -> bool : \"\"\"Checks to see if there have been any updates to the Cookiecutter template used to generate this project. \"\"\" cruft_file = os . path . join ( expanded_dir , \".cruft.json\" ) if not os . path . isfile ( cruft_file ): raise NoCruftFound ( os . path . abspath ( expanded_dir )) with open ( cruft_file ) as cruft_open_file : cruft_state = json . load ( cruft_open_file ) with TemporaryDirectory () as cookiecutter_template_dir : repo = Repo . clone_from ( cruft_state [ \"template\" ], cookiecutter_template_dir ) last_commit = repo . head . object . hexsha if last_commit == cruft_state [ \"commit\" ] or not repo . index . diff ( cruft_state [ \"commit\" ]): return True return False def _generate_output ( context_file : str , cruft_state : dict , cookiecutter_input : bool , template_dir : str , output_dir : str , ) -> dict : context = generate_context ( context_file = context_file , extra_context = cruft_state [ \"context\" ][ \"cookiecutter\" ] ) context [ \"cookiecutter\" ] = prompt_for_config ( context , not cookiecutter_input ) context [ \"cookiecutter\" ][ \"_template\" ] = cruft_state [ \"template\" ] generate_files ( repo_dir = template_dir , context = context , overwrite_if_exists = True , output_dir = output_dir ) return context @example () @example ( skip_apply_ask = True ) def update ( expanded_dir : str = \".\" , cookiecutter_input : bool = False , skip_apply_ask : bool = False , skip_update : bool = False , ) -> bool : \"\"\"Update specified project's cruft to the latest and greatest release.\"\"\" cruft_file = os . path . join ( expanded_dir , \".cruft.json\" ) if not os . path . isfile ( cruft_file ): raise NoCruftFound ( os . path . abspath ( expanded_dir )) with open ( cruft_file ) as cruft_open_file : cruft_state = json . load ( cruft_open_file ) with TemporaryDirectory () as compare_directory : template_dir = os . path . join ( compare_directory , \"template\" ) try : repo = Repo . clone_from ( cruft_state [ \"template\" ], template_dir ) last_commit = repo . head . object . hexsha except Exception as e : # pragma: no cover raise InvalidCookiecutterRepository ( e ) if last_commit == cruft_state [ \"commit\" ] or not repo . index . diff ( cruft_state [ \"commit\" ]): return False context_file = os . path . join ( template_dir , \"cookiecutter.json\" ) new_output_dir = os . path . join ( compare_directory , \"new_output\" ) new_context = _generate_output ( context_file = context_file , cruft_state = cruft_state , cookiecutter_input = cookiecutter_input , template_dir = template_dir , output_dir = new_output_dir , ) old_output_dir = os . path . join ( compare_directory , \"old_output\" ) repo . head . reset ( commit = cruft_state [ \"commit\" ], working_tree = True ) _generate_output ( context_file = context_file , cruft_state = cruft_state , cookiecutter_input = cookiecutter_input , template_dir = template_dir , output_dir = old_output_dir , ) main_directory : str = \"\" for file_name in os . listdir ( old_output_dir ): file_path = os . path . join ( old_output_dir , file_name ) if os . path . isdir ( file_path ): main_directory = file_name new_main_directory = os . path . join ( new_output_dir , main_directory ) old_main_directory = os . path . join ( old_output_dir , main_directory ) for skip_file in cruft_state . get ( \"skip\" , []): file_path_old = os . path . join ( old_main_directory , skip_file ) file_path_new = os . path . join ( new_main_directory , skip_file ) for file_path in ( file_path_old , file_path_new ): if os . path . isdir ( file_path ): rmtree ( file_path ) else : os . remove ( file_path ) diff = run ( [ \"git\" , \"diff\" , \"--no-index\" , old_main_directory , new_main_directory ], stdout = PIPE , stderr = PIPE , ) . stdout . decode ( \"utf8\" ) diff = diff . replace ( old_main_directory , \"\" ) . replace ( new_main_directory , \"\" ) print ( \"The following diff would be applied: \\n \" ) print ( diff ) print ( \"\" ) if not skip_apply_ask and not skip_update : # pragma: no cover update : str = \"\" while update not in ( \"y\" , \"n\" , \"s\" ): print ( 'Respond with \"s\" to intentionally skip the update while marking ' \"your project as up-to-date.\" ) update = input ( \"Apply diff and update [y/n/s]? \" ) . lower () # nosec if update == \"n\" : sys . exit ( \"User cancelled Cookiecutter template update.\" ) elif update == \"s\" : skip_update = True current_directory = os . getcwd () try : os . chdir ( expanded_dir ) if not skip_update : run ([ \"patch\" , \"--merge\" ], input = diff . encode ( \"utf8\" )) cruft_state [ \"commit\" ] = last_commit cruft_state [ \"context\" ] = new_context with open ( cruft_file , \"w\" ) as cruft_output : json_dump ( cruft_state , cruft_output ) finally : os . chdir ( current_directory ) return True @example ( \"https://github.com/timothycrosley/cookiecutter-python/\" , no_input = True , use_latest = True ) def link ( template_git_url : str , project_dir : str = \".\" , use_latest : bool = False , no_input : bool = False , config_file : Optional [ str ] = None , default_config : bool = False , extra_context : Optional [ dict ] = None , ) -> bool : \"\"\"Links an existing project created from a template, to the template it was created from.\"\"\" cruft_file = os . path . join ( project_dir , \".cruft.json\" ) if os . path . isfile ( os . path . join ( project_dir , \".cruft.json\" )): raise CruftAlreadyPresent ( cruft_file ) with TemporaryDirectory () as cookiecutter_template_dir : try : repo = Repo . clone_from ( template_git_url , cookiecutter_template_dir ) last_commit = repo . head . object . hexsha except Exception as e : # pragma: no cover raise InvalidCookiecutterRepository ( e ) main_cookiecutter_directory : str = \"\" for file_name in os . listdir ( cookiecutter_template_dir ): file_path = os . path . join ( cookiecutter_template_dir , file_name ) if ( os . path . isdir ( file_path ) and \"{{\" in file_name and \"}}\" in file_name and \"cookiecutter.\" in file_name ): main_cookiecutter_directory = file_path break if not main_cookiecutter_directory : # pragma: no cover raise UnableToFindCookiecutterTemplate ( cookiecutter_template_dir ) context_file = os . path . join ( cookiecutter_template_dir , \"cookiecutter.json\" ) config_dict = get_user_config ( config_file = config_file , default_config = default_config ) context = generate_context ( context_file = context_file , default_context = config_dict [ \"default_context\" ], extra_context = extra_context , ) # prompt the user to manually configure at the command line. # except when 'no-input' flag is set context [ \"cookiecutter\" ] = prompt_for_config ( context , no_input ) context [ \"cookiecutter\" ][ \"_template\" ] = template_git_url if use_latest or no_input : use_commit = last_commit else : # pragma: no cover print ( \"\" ) print ( f \"The latest commit to the template is {last_commit}\" ) print ( \"Press enter to link against this commit or provide an alternative commit.\" ) print ( \"\" ) use_commit = input ( f \"Link to template at commit [{last_commit}]: \" ) # nosec use_commit = use_commit if use_commit . strip () else last_commit with open ( cruft_file , \"w\" ) as write_cruft : json_dump ( { \"template\" : template_git_url , \"commit\" : use_commit , \"context\" : context }, write_cruft , ) return True Variables PIPE json_dump Functions check def check ( expanded_dir : str = '.' ) -> bool Checks to see if there have been any updates to the Cookiecutter template used to generate this project. Examples: check ( ) View Source @ example () def check ( expanded_dir : str = \" . \" ) -> bool : \"\"\" Checks to see if there have been any updates to the Cookiecutter template used to generate this project . \"\"\" cruft_file = os . path . join ( expanded_dir , \" .cruft.json \" ) if not os . path . isfile ( cruft_file ) : raise NoCruftFound ( os . path . abspath ( expanded_dir )) with open ( cruft_file ) as cruft_open_file : cruft_state = json . load ( cruft_open_file ) with TemporaryDirectory () as cookiecutter_template_dir : repo = Repo . clone_from ( cruft_state [ \" template \" ], cookiecutter_template_dir ) last_commit = repo . head . object . hexsha if last_commit == cruft_state [ \" commit \" ] or not repo . index . diff ( cruft_state [ \" commit \" ] ) : return True return False create def create ( template_git_url : str , output_dir : str = '.' , config_file : Union [ str , NoneType ] = None , default_config : bool = False , extra_context : Union [ dict , NoneType ] = None , no_input : bool = False , overwrite_if_exists : bool = False ) -> str Expand a Git based Cookiecutter template into a new project on disk. Examples: create ( 'https://github.com/timothycrosley/cookiecutter-python/' , no_input = True ) View Source @ example ( \" https://github.com/timothycrosley/cookiecutter-python/ \" , no_input = True ) def create ( template_git_url : str , output_dir : str = \" . \" , config_file : Optional [ str ] = None , default_config : bool = False , extra_context : Optional [ dict ] = None , no_input : bool = False , overwrite_if_exists : bool = False , ) -> str : \"\"\" Expand a Git based Cookiecutter template into a new project on disk. \"\"\" with TemporaryDirectory () as cookiecutter_template_dir : try : repo = Repo . clone_from ( template_git_url , cookiecutter_template_dir ) last_commit = repo . head . object . hexsha except Exception as e : raise InvalidCookiecutterRepository ( e ) main_cookiecutter_directory : str = \"\" for file_name in os . listdir ( cookiecutter_template_dir ) : file_path = os . path . join ( cookiecutter_template_dir , file_name ) if ( os . path . isdir ( file_path ) and \" {{ \" in file_name and \" }} \" in file_name and \" cookiecutter. \" in file_name ) : main_cookiecutter_directory = file_path break if not main_cookiecutter_directory : # pragma : no cover raise UnableToFindCookiecutterTemplate ( cookiecutter_template_dir ) context_file = os . path . join ( cookiecutter_template_dir , \" cookiecutter.json \" ) config_dict = get_user_config ( config_file = config_file , default_config = default_config ) context = generate_context ( context_file = context_file , default_context = config_dict [ \" default_context \" ], extra_context = extra_context , ) # prompt the user to manually configure at the command line . # except when ' no-input ' flag is set context [ \" cookiecutter \" ] = prompt_for_config ( context , no_input ) context [ \" cookiecutter \" ][ \" _template \" ] = template_git_url with open ( os . path . join ( main_cookiecutter_directory , \" .cruft.json \" ) , \" w \" ) as cruft_file : json_dump ( { \" template \" : template_git_url , \" commit \" : last_commit , \" context \" : context }, cruft_file , ) return generate_files ( repo_dir = cookiecutter_template_dir , context = context , overwrite_if_exists = overwrite_if_exists , output_dir = output_dir , ) link def link ( template_git_url : str , project_dir : str = '.' , use_latest : bool = False , no_input : bool = False , config_file : Union [ str , NoneType ] = None , default_config : bool = False , extra_context : Union [ dict , NoneType ] = None ) -> bool Links an existing project created from a template, to the template it was created from. Examples: link ( 'https://github.com/timothycrosley/cookiecutter-python/' , no_input = True , use_latest = True ) View Source @ example ( \" https://github.com/timothycrosley/cookiecutter-python/ \" , no_input = True , use_latest = True ) def link ( template_git_url : str , project_dir : str = \" . \" , use_latest : bool = False , no_input : bool = False , config_file : Optional [ str ] = None , default_config : bool = False , extra_context : Optional [ dict ] = None , ) -> bool : \"\"\" Links an existing project created from a template, to the template it was created from. \"\"\" cruft_file = os . path . join ( project_dir , \" .cruft.json \" ) if os . path . isfile ( os . path . join ( project_dir , \" .cruft.json \" )) : raise CruftAlreadyPresent ( cruft_file ) with TemporaryDirectory () as cookiecutter_template_dir : try : repo = Repo . clone_from ( template_git_url , cookiecutter_template_dir ) last_commit = repo . head . object . hexsha except Exception as e : # pragma : no cover raise InvalidCookiecutterRepository ( e ) main_cookiecutter_directory : str = \"\" for file_name in os . listdir ( cookiecutter_template_dir ) : file_path = os . path . join ( cookiecutter_template_dir , file_name ) if ( os . path . isdir ( file_path ) and \" {{ \" in file_name and \" }} \" in file_name and \" cookiecutter. \" in file_name ) : main_cookiecutter_directory = file_path break if not main_cookiecutter_directory : # pragma : no cover raise UnableToFindCookiecutterTemplate ( cookiecutter_template_dir ) context_file = os . path . join ( cookiecutter_template_dir , \" cookiecutter.json \" ) config_dict = get_user_config ( config_file = config_file , default_config = default_config ) context = generate_context ( context_file = context_file , default_context = config_dict [ \" default_context \" ], extra_context = extra_context , ) # prompt the user to manually configure at the command line . # except when ' no-input ' flag is set context [ \" cookiecutter \" ] = prompt_for_config ( context , no_input ) context [ \" cookiecutter \" ][ \" _template \" ] = template_git_url if use_latest or no_input : use_commit = last_commit else : # pragma : no cover print ( \"\" ) print ( f \" The latest commit to the template is {last_commit} \" ) print ( \" Press enter to link against this commit or provide an alternative commit. \" ) print ( \"\" ) use_commit = input ( f \" Link to template at commit [{last_commit}]: \" ) # nosec use_commit = use_commit if use_commit . strip () else last_commit with open ( cruft_file , \" w \" ) as write_cruft : json_dump ( { \" template \" : template_git_url , \" commit \" : use_commit , \" context \" : context }, write_cruft , ) return True update def update ( expanded_dir : str = '.' , cookiecutter_input : bool = False , skip_apply_ask : bool = False , skip_update : bool = False ) -> bool Update specified project's cruft to the latest and greatest release. Examples: update ( skip_apply_ask = True ) update ( ) View Source @ example () @ example ( skip_apply_ask = True ) def update ( expanded_dir : str = \" . \" , cookiecutter_input : bool = False , skip_apply_ask : bool = False , skip_update : bool = False , ) -> bool : \"\"\" Update specified project's cruft to the latest and greatest release. \"\"\" cruft_file = os . path . join ( expanded_dir , \" .cruft.json \" ) if not os . path . isfile ( cruft_file ) : raise NoCruftFound ( os . path . abspath ( expanded_dir )) with open ( cruft_file ) as cruft_open_file : cruft_state = json . load ( cruft_open_file ) with TemporaryDirectory () as compare_directory : template_dir = os . path . join ( compare_directory , \" template \" ) try : repo = Repo . clone_from ( cruft_state [ \" template \" ], template_dir ) last_commit = repo . head . object . hexsha except Exception as e : # pragma : no cover raise InvalidCookiecutterRepository ( e ) if last_commit == cruft_state [ \" commit \" ] or not repo . index . diff ( cruft_state [ \" commit \" ] ) : return False context_file = os . path . join ( template_dir , \" cookiecutter.json \" ) new_output_dir = os . path . join ( compare_directory , \" new_output \" ) new_context = _generate_output ( context_file = context_file , cruft_state = cruft_state , cookiecutter_input = cookiecutter_input , template_dir = template_dir , output_dir = new_output_dir , ) old_output_dir = os . path . join ( compare_directory , \" old_output \" ) repo . head . reset ( commit = cruft_state [ \" commit \" ], working_tree = True ) _generate_output ( context_file = context_file , cruft_state = cruft_state , cookiecutter_input = cookiecutter_input , template_dir = template_dir , output_dir = old_output_dir , ) main_directory : str = \"\" for file_name in os . listdir ( old_output_dir ) : file_path = os . path . join ( old_output_dir , file_name ) if os . path . isdir ( file_path ) : main_directory = file_name new_main_directory = os . path . join ( new_output_dir , main_directory ) old_main_directory = os . path . join ( old_output_dir , main_directory ) for skip_file in cruft_state . get ( \" skip \" , [] ) : file_path_old = os . path . join ( old_main_directory , skip_file ) file_path_new = os . path . join ( new_main_directory , skip_file ) for file_path in ( file_path_old , file_path_new ) : if os . path . isdir ( file_path ) : rmtree ( file_path ) else : os . remove ( file_path ) diff = run ( [ \" git \" , \" diff \" , \" --no-index \" , old_main_directory , new_main_directory ], stdout = PIPE , stderr = PIPE , ) . stdout . decode ( \" utf8 \" ) diff = diff . replace ( old_main_directory , \"\" ) . replace ( new_main_directory , \"\" ) print ( \" The following diff would be applied: \\n \" ) print ( diff ) print ( \"\" ) if not skip_apply_ask and not skip_update : # pragma : no cover update : str = \"\" while update not in ( \" y \" , \" n \" , \" s \" ) : print ( ' Respond with \"s\" to intentionally skip the update while marking ' \" your project as up-to-date. \" ) update = input ( \" Apply diff and update [y/n/s]? \" ) . lower () # nosec if update == \" n \" : sys . exit ( \" User cancelled Cookiecutter template update. \" ) elif update == \" s \" : skip_update = True current_directory = os . getcwd () try : os . chdir ( expanded_dir ) if not skip_update : run ( [ \" patch \" , \" --merge \" ], input = diff . encode ( \" utf8 \" )) cruft_state [ \" commit \" ] = last_commit cruft_state [ \" context \" ] = new_context with open ( cruft_file , \" w \" ) as cruft_output : json_dump ( cruft_state , cruft_output ) finally : os . chdir ( current_directory ) return True","title":"API"},{"location":"reference/cruft/api/#module-cruftapi","text":"View Source import json import os import sys from functools import partial from pathlib import Path from shutil import move , rmtree from subprocess import PIPE , run # nosec from tempfile import TemporaryDirectory from typing import Optional from cookiecutter.config import get_user_config from cookiecutter.generate import generate_context , generate_files from cookiecutter.prompt import prompt_for_config from examples import example from git import Repo from cruft.exceptions import ( CruftAlreadyPresent , InvalidCookiecutterRepository , NoCruftFound , UnableToFindCookiecutterTemplate , ) json_dump = partial ( json . dump , ensure_ascii = False , indent = 4 , separators = ( \",\" , \": \" )) @example ( \"https://github.com/timothycrosley/cookiecutter-python/\" , no_input = True ) def create ( template_git_url : str , output_dir : str = \".\" , config_file : Optional [ str ] = None , default_config : bool = False , extra_context : Optional [ dict ] = None , no_input : bool = False , overwrite_if_exists : bool = False , ) -> str : \"\"\"Expand a Git based Cookiecutter template into a new project on disk.\"\"\" with TemporaryDirectory () as cookiecutter_template_dir : try : repo = Repo . clone_from ( template_git_url , cookiecutter_template_dir ) last_commit = repo . head . object . hexsha except Exception as e : raise InvalidCookiecutterRepository ( e ) main_cookiecutter_directory : str = \"\" for file_name in os . listdir ( cookiecutter_template_dir ): file_path = os . path . join ( cookiecutter_template_dir , file_name ) if ( os . path . isdir ( file_path ) and \"{{\" in file_name and \"}}\" in file_name and \"cookiecutter.\" in file_name ): main_cookiecutter_directory = file_path break if not main_cookiecutter_directory : # pragma: no cover raise UnableToFindCookiecutterTemplate ( cookiecutter_template_dir ) context_file = os . path . join ( cookiecutter_template_dir , \"cookiecutter.json\" ) config_dict = get_user_config ( config_file = config_file , default_config = default_config ) context = generate_context ( context_file = context_file , default_context = config_dict [ \"default_context\" ], extra_context = extra_context , ) # prompt the user to manually configure at the command line. # except when 'no-input' flag is set context [ \"cookiecutter\" ] = prompt_for_config ( context , no_input ) context [ \"cookiecutter\" ][ \"_template\" ] = template_git_url with open ( os . path . join ( main_cookiecutter_directory , \".cruft.json\" ), \"w\" ) as cruft_file : json_dump ( { \"template\" : template_git_url , \"commit\" : last_commit , \"context\" : context }, cruft_file , ) return generate_files ( repo_dir = cookiecutter_template_dir , context = context , overwrite_if_exists = overwrite_if_exists , output_dir = output_dir , ) @example () def check ( expanded_dir : str = \".\" ) -> bool : \"\"\"Checks to see if there have been any updates to the Cookiecutter template used to generate this project. \"\"\" cruft_file = os . path . join ( expanded_dir , \".cruft.json\" ) if not os . path . isfile ( cruft_file ): raise NoCruftFound ( os . path . abspath ( expanded_dir )) with open ( cruft_file ) as cruft_open_file : cruft_state = json . load ( cruft_open_file ) with TemporaryDirectory () as cookiecutter_template_dir : repo = Repo . clone_from ( cruft_state [ \"template\" ], cookiecutter_template_dir ) last_commit = repo . head . object . hexsha if last_commit == cruft_state [ \"commit\" ] or not repo . index . diff ( cruft_state [ \"commit\" ]): return True return False def _generate_output ( context_file : str , cruft_state : dict , cookiecutter_input : bool , template_dir : str , output_dir : str , ) -> dict : context = generate_context ( context_file = context_file , extra_context = cruft_state [ \"context\" ][ \"cookiecutter\" ] ) context [ \"cookiecutter\" ] = prompt_for_config ( context , not cookiecutter_input ) context [ \"cookiecutter\" ][ \"_template\" ] = cruft_state [ \"template\" ] generate_files ( repo_dir = template_dir , context = context , overwrite_if_exists = True , output_dir = output_dir ) return context @example () @example ( skip_apply_ask = True ) def update ( expanded_dir : str = \".\" , cookiecutter_input : bool = False , skip_apply_ask : bool = False , skip_update : bool = False , ) -> bool : \"\"\"Update specified project's cruft to the latest and greatest release.\"\"\" cruft_file = os . path . join ( expanded_dir , \".cruft.json\" ) if not os . path . isfile ( cruft_file ): raise NoCruftFound ( os . path . abspath ( expanded_dir )) with open ( cruft_file ) as cruft_open_file : cruft_state = json . load ( cruft_open_file ) with TemporaryDirectory () as compare_directory : template_dir = os . path . join ( compare_directory , \"template\" ) try : repo = Repo . clone_from ( cruft_state [ \"template\" ], template_dir ) last_commit = repo . head . object . hexsha except Exception as e : # pragma: no cover raise InvalidCookiecutterRepository ( e ) if last_commit == cruft_state [ \"commit\" ] or not repo . index . diff ( cruft_state [ \"commit\" ]): return False context_file = os . path . join ( template_dir , \"cookiecutter.json\" ) new_output_dir = os . path . join ( compare_directory , \"new_output\" ) new_context = _generate_output ( context_file = context_file , cruft_state = cruft_state , cookiecutter_input = cookiecutter_input , template_dir = template_dir , output_dir = new_output_dir , ) old_output_dir = os . path . join ( compare_directory , \"old_output\" ) repo . head . reset ( commit = cruft_state [ \"commit\" ], working_tree = True ) _generate_output ( context_file = context_file , cruft_state = cruft_state , cookiecutter_input = cookiecutter_input , template_dir = template_dir , output_dir = old_output_dir , ) main_directory : str = \"\" for file_name in os . listdir ( old_output_dir ): file_path = os . path . join ( old_output_dir , file_name ) if os . path . isdir ( file_path ): main_directory = file_name new_main_directory = os . path . join ( new_output_dir , main_directory ) old_main_directory = os . path . join ( old_output_dir , main_directory ) for skip_file in cruft_state . get ( \"skip\" , []): file_path_old = os . path . join ( old_main_directory , skip_file ) file_path_new = os . path . join ( new_main_directory , skip_file ) for file_path in ( file_path_old , file_path_new ): if os . path . isdir ( file_path ): rmtree ( file_path ) else : os . remove ( file_path ) diff = run ( [ \"git\" , \"diff\" , \"--no-index\" , old_main_directory , new_main_directory ], stdout = PIPE , stderr = PIPE , ) . stdout . decode ( \"utf8\" ) diff = diff . replace ( old_main_directory , \"\" ) . replace ( new_main_directory , \"\" ) print ( \"The following diff would be applied: \\n \" ) print ( diff ) print ( \"\" ) if not skip_apply_ask and not skip_update : # pragma: no cover update : str = \"\" while update not in ( \"y\" , \"n\" , \"s\" ): print ( 'Respond with \"s\" to intentionally skip the update while marking ' \"your project as up-to-date.\" ) update = input ( \"Apply diff and update [y/n/s]? \" ) . lower () # nosec if update == \"n\" : sys . exit ( \"User cancelled Cookiecutter template update.\" ) elif update == \"s\" : skip_update = True current_directory = os . getcwd () try : os . chdir ( expanded_dir ) if not skip_update : run ([ \"patch\" , \"--merge\" ], input = diff . encode ( \"utf8\" )) cruft_state [ \"commit\" ] = last_commit cruft_state [ \"context\" ] = new_context with open ( cruft_file , \"w\" ) as cruft_output : json_dump ( cruft_state , cruft_output ) finally : os . chdir ( current_directory ) return True @example ( \"https://github.com/timothycrosley/cookiecutter-python/\" , no_input = True , use_latest = True ) def link ( template_git_url : str , project_dir : str = \".\" , use_latest : bool = False , no_input : bool = False , config_file : Optional [ str ] = None , default_config : bool = False , extra_context : Optional [ dict ] = None , ) -> bool : \"\"\"Links an existing project created from a template, to the template it was created from.\"\"\" cruft_file = os . path . join ( project_dir , \".cruft.json\" ) if os . path . isfile ( os . path . join ( project_dir , \".cruft.json\" )): raise CruftAlreadyPresent ( cruft_file ) with TemporaryDirectory () as cookiecutter_template_dir : try : repo = Repo . clone_from ( template_git_url , cookiecutter_template_dir ) last_commit = repo . head . object . hexsha except Exception as e : # pragma: no cover raise InvalidCookiecutterRepository ( e ) main_cookiecutter_directory : str = \"\" for file_name in os . listdir ( cookiecutter_template_dir ): file_path = os . path . join ( cookiecutter_template_dir , file_name ) if ( os . path . isdir ( file_path ) and \"{{\" in file_name and \"}}\" in file_name and \"cookiecutter.\" in file_name ): main_cookiecutter_directory = file_path break if not main_cookiecutter_directory : # pragma: no cover raise UnableToFindCookiecutterTemplate ( cookiecutter_template_dir ) context_file = os . path . join ( cookiecutter_template_dir , \"cookiecutter.json\" ) config_dict = get_user_config ( config_file = config_file , default_config = default_config ) context = generate_context ( context_file = context_file , default_context = config_dict [ \"default_context\" ], extra_context = extra_context , ) # prompt the user to manually configure at the command line. # except when 'no-input' flag is set context [ \"cookiecutter\" ] = prompt_for_config ( context , no_input ) context [ \"cookiecutter\" ][ \"_template\" ] = template_git_url if use_latest or no_input : use_commit = last_commit else : # pragma: no cover print ( \"\" ) print ( f \"The latest commit to the template is {last_commit}\" ) print ( \"Press enter to link against this commit or provide an alternative commit.\" ) print ( \"\" ) use_commit = input ( f \"Link to template at commit [{last_commit}]: \" ) # nosec use_commit = use_commit if use_commit . strip () else last_commit with open ( cruft_file , \"w\" ) as write_cruft : json_dump ( { \"template\" : template_git_url , \"commit\" : use_commit , \"context\" : context }, write_cruft , ) return True","title":"Module cruft.api"},{"location":"reference/cruft/api/#variables","text":"PIPE json_dump","title":"Variables"},{"location":"reference/cruft/api/#functions","text":"","title":"Functions"},{"location":"reference/cruft/api/#check","text":"def check ( expanded_dir : str = '.' ) -> bool Checks to see if there have been any updates to the Cookiecutter template used to generate this project. Examples: check ( ) View Source @ example () def check ( expanded_dir : str = \" . \" ) -> bool : \"\"\" Checks to see if there have been any updates to the Cookiecutter template used to generate this project . \"\"\" cruft_file = os . path . join ( expanded_dir , \" .cruft.json \" ) if not os . path . isfile ( cruft_file ) : raise NoCruftFound ( os . path . abspath ( expanded_dir )) with open ( cruft_file ) as cruft_open_file : cruft_state = json . load ( cruft_open_file ) with TemporaryDirectory () as cookiecutter_template_dir : repo = Repo . clone_from ( cruft_state [ \" template \" ], cookiecutter_template_dir ) last_commit = repo . head . object . hexsha if last_commit == cruft_state [ \" commit \" ] or not repo . index . diff ( cruft_state [ \" commit \" ] ) : return True return False","title":"check"},{"location":"reference/cruft/api/#create","text":"def create ( template_git_url : str , output_dir : str = '.' , config_file : Union [ str , NoneType ] = None , default_config : bool = False , extra_context : Union [ dict , NoneType ] = None , no_input : bool = False , overwrite_if_exists : bool = False ) -> str Expand a Git based Cookiecutter template into a new project on disk. Examples: create ( 'https://github.com/timothycrosley/cookiecutter-python/' , no_input = True ) View Source @ example ( \" https://github.com/timothycrosley/cookiecutter-python/ \" , no_input = True ) def create ( template_git_url : str , output_dir : str = \" . \" , config_file : Optional [ str ] = None , default_config : bool = False , extra_context : Optional [ dict ] = None , no_input : bool = False , overwrite_if_exists : bool = False , ) -> str : \"\"\" Expand a Git based Cookiecutter template into a new project on disk. \"\"\" with TemporaryDirectory () as cookiecutter_template_dir : try : repo = Repo . clone_from ( template_git_url , cookiecutter_template_dir ) last_commit = repo . head . object . hexsha except Exception as e : raise InvalidCookiecutterRepository ( e ) main_cookiecutter_directory : str = \"\" for file_name in os . listdir ( cookiecutter_template_dir ) : file_path = os . path . join ( cookiecutter_template_dir , file_name ) if ( os . path . isdir ( file_path ) and \" {{ \" in file_name and \" }} \" in file_name and \" cookiecutter. \" in file_name ) : main_cookiecutter_directory = file_path break if not main_cookiecutter_directory : # pragma : no cover raise UnableToFindCookiecutterTemplate ( cookiecutter_template_dir ) context_file = os . path . join ( cookiecutter_template_dir , \" cookiecutter.json \" ) config_dict = get_user_config ( config_file = config_file , default_config = default_config ) context = generate_context ( context_file = context_file , default_context = config_dict [ \" default_context \" ], extra_context = extra_context , ) # prompt the user to manually configure at the command line . # except when ' no-input ' flag is set context [ \" cookiecutter \" ] = prompt_for_config ( context , no_input ) context [ \" cookiecutter \" ][ \" _template \" ] = template_git_url with open ( os . path . join ( main_cookiecutter_directory , \" .cruft.json \" ) , \" w \" ) as cruft_file : json_dump ( { \" template \" : template_git_url , \" commit \" : last_commit , \" context \" : context }, cruft_file , ) return generate_files ( repo_dir = cookiecutter_template_dir , context = context , overwrite_if_exists = overwrite_if_exists , output_dir = output_dir , )","title":"create"},{"location":"reference/cruft/api/#link","text":"def link ( template_git_url : str , project_dir : str = '.' , use_latest : bool = False , no_input : bool = False , config_file : Union [ str , NoneType ] = None , default_config : bool = False , extra_context : Union [ dict , NoneType ] = None ) -> bool Links an existing project created from a template, to the template it was created from. Examples: link ( 'https://github.com/timothycrosley/cookiecutter-python/' , no_input = True , use_latest = True ) View Source @ example ( \" https://github.com/timothycrosley/cookiecutter-python/ \" , no_input = True , use_latest = True ) def link ( template_git_url : str , project_dir : str = \" . \" , use_latest : bool = False , no_input : bool = False , config_file : Optional [ str ] = None , default_config : bool = False , extra_context : Optional [ dict ] = None , ) -> bool : \"\"\" Links an existing project created from a template, to the template it was created from. \"\"\" cruft_file = os . path . join ( project_dir , \" .cruft.json \" ) if os . path . isfile ( os . path . join ( project_dir , \" .cruft.json \" )) : raise CruftAlreadyPresent ( cruft_file ) with TemporaryDirectory () as cookiecutter_template_dir : try : repo = Repo . clone_from ( template_git_url , cookiecutter_template_dir ) last_commit = repo . head . object . hexsha except Exception as e : # pragma : no cover raise InvalidCookiecutterRepository ( e ) main_cookiecutter_directory : str = \"\" for file_name in os . listdir ( cookiecutter_template_dir ) : file_path = os . path . join ( cookiecutter_template_dir , file_name ) if ( os . path . isdir ( file_path ) and \" {{ \" in file_name and \" }} \" in file_name and \" cookiecutter. \" in file_name ) : main_cookiecutter_directory = file_path break if not main_cookiecutter_directory : # pragma : no cover raise UnableToFindCookiecutterTemplate ( cookiecutter_template_dir ) context_file = os . path . join ( cookiecutter_template_dir , \" cookiecutter.json \" ) config_dict = get_user_config ( config_file = config_file , default_config = default_config ) context = generate_context ( context_file = context_file , default_context = config_dict [ \" default_context \" ], extra_context = extra_context , ) # prompt the user to manually configure at the command line . # except when ' no-input ' flag is set context [ \" cookiecutter \" ] = prompt_for_config ( context , no_input ) context [ \" cookiecutter \" ][ \" _template \" ] = template_git_url if use_latest or no_input : use_commit = last_commit else : # pragma : no cover print ( \"\" ) print ( f \" The latest commit to the template is {last_commit} \" ) print ( \" Press enter to link against this commit or provide an alternative commit. \" ) print ( \"\" ) use_commit = input ( f \" Link to template at commit [{last_commit}]: \" ) # nosec use_commit = use_commit if use_commit . strip () else last_commit with open ( cruft_file , \" w \" ) as write_cruft : json_dump ( { \" template \" : template_git_url , \" commit \" : use_commit , \" context \" : context }, write_cruft , ) return True","title":"link"},{"location":"reference/cruft/api/#update","text":"def update ( expanded_dir : str = '.' , cookiecutter_input : bool = False , skip_apply_ask : bool = False , skip_update : bool = False ) -> bool Update specified project's cruft to the latest and greatest release. Examples: update ( skip_apply_ask = True ) update ( ) View Source @ example () @ example ( skip_apply_ask = True ) def update ( expanded_dir : str = \" . \" , cookiecutter_input : bool = False , skip_apply_ask : bool = False , skip_update : bool = False , ) -> bool : \"\"\" Update specified project's cruft to the latest and greatest release. \"\"\" cruft_file = os . path . join ( expanded_dir , \" .cruft.json \" ) if not os . path . isfile ( cruft_file ) : raise NoCruftFound ( os . path . abspath ( expanded_dir )) with open ( cruft_file ) as cruft_open_file : cruft_state = json . load ( cruft_open_file ) with TemporaryDirectory () as compare_directory : template_dir = os . path . join ( compare_directory , \" template \" ) try : repo = Repo . clone_from ( cruft_state [ \" template \" ], template_dir ) last_commit = repo . head . object . hexsha except Exception as e : # pragma : no cover raise InvalidCookiecutterRepository ( e ) if last_commit == cruft_state [ \" commit \" ] or not repo . index . diff ( cruft_state [ \" commit \" ] ) : return False context_file = os . path . join ( template_dir , \" cookiecutter.json \" ) new_output_dir = os . path . join ( compare_directory , \" new_output \" ) new_context = _generate_output ( context_file = context_file , cruft_state = cruft_state , cookiecutter_input = cookiecutter_input , template_dir = template_dir , output_dir = new_output_dir , ) old_output_dir = os . path . join ( compare_directory , \" old_output \" ) repo . head . reset ( commit = cruft_state [ \" commit \" ], working_tree = True ) _generate_output ( context_file = context_file , cruft_state = cruft_state , cookiecutter_input = cookiecutter_input , template_dir = template_dir , output_dir = old_output_dir , ) main_directory : str = \"\" for file_name in os . listdir ( old_output_dir ) : file_path = os . path . join ( old_output_dir , file_name ) if os . path . isdir ( file_path ) : main_directory = file_name new_main_directory = os . path . join ( new_output_dir , main_directory ) old_main_directory = os . path . join ( old_output_dir , main_directory ) for skip_file in cruft_state . get ( \" skip \" , [] ) : file_path_old = os . path . join ( old_main_directory , skip_file ) file_path_new = os . path . join ( new_main_directory , skip_file ) for file_path in ( file_path_old , file_path_new ) : if os . path . isdir ( file_path ) : rmtree ( file_path ) else : os . remove ( file_path ) diff = run ( [ \" git \" , \" diff \" , \" --no-index \" , old_main_directory , new_main_directory ], stdout = PIPE , stderr = PIPE , ) . stdout . decode ( \" utf8 \" ) diff = diff . replace ( old_main_directory , \"\" ) . replace ( new_main_directory , \"\" ) print ( \" The following diff would be applied: \\n \" ) print ( diff ) print ( \"\" ) if not skip_apply_ask and not skip_update : # pragma : no cover update : str = \"\" while update not in ( \" y \" , \" n \" , \" s \" ) : print ( ' Respond with \"s\" to intentionally skip the update while marking ' \" your project as up-to-date. \" ) update = input ( \" Apply diff and update [y/n/s]? \" ) . lower () # nosec if update == \" n \" : sys . exit ( \" User cancelled Cookiecutter template update. \" ) elif update == \" s \" : skip_update = True current_directory = os . getcwd () try : os . chdir ( expanded_dir ) if not skip_update : run ( [ \" patch \" , \" --merge \" ], input = diff . encode ( \" utf8 \" )) cruft_state [ \" commit \" ] = last_commit cruft_state [ \" context \" ] = new_context with open ( cruft_file , \" w \" ) as cruft_output : json_dump ( cruft_state , cruft_output ) finally : os . chdir ( current_directory ) return True","title":"update"},{"location":"reference/cruft/cli/","text":"Module cruft.cli This module defines CLI interaction when using cruft . This is powered by hug which means unless necessary it should maintain 1:1 compatibility with the programmatic API definition in the API module cruft create : Expands the specified Cookiecutter template on disk. cruft check : Checks to see if the expanded template is up-to-date with latest version. cruft update : Attempts to updates an expanded Cookiecutter template to the latest version. View Source \"\"\"This module defines CLI interaction when using `cruft`. This is powered by [hug](https://github.com/hugapi/hug) which means unless necessary it should maintain 1:1 compatibility with the programmatic API definition in the [API module](/reference/cruft/api) - `cruft create`: Expands the specified Cookiecutter template on disk. - `cruft check`: Checks to see if the expanded template is up-to-date with latest version. - `cruft update`: Attempts to updates an expanded Cookiecutter template to the latest version. \"\"\" import sys import hug from cruft import api , logo def _check_command_output ( up_to_date : bool ) -> None : if not up_to_date : print ( \"\" ) sys . exit ( \"FAILURE: Project's cruft is out of date! Run `cruft update` to clean this mess up.\" ) else : print ( \"\" ) print ( \"SUCCESS: Good work! Project's cruft is up to date and as clean as possible :).\" ) def _update_output ( updated : bool ) -> None : if not updated : print ( \"\" ) print ( \"Nothing to do, project's cruft is already up to date!\" ) else : print ( \"\" ) print ( \"Good work! Project's cruft has been updated and is as clean as possible!\" ) def _link_output ( linked : bool ) -> None : if linked : print ( \"\" ) print ( \"Project successfully linked to template!\" ) else : print ( \"\" ) print ( \"Project linking failed :(\" ) cli = hug . cli ( api = hug . API ( __name__ , doc = logo . ascii_art )) cli ( api . create ) cli . output ( _update_output )( api . update ) cli . output ( _check_command_output )( api . check ) cli . output ( _link_output )( api . link ) Variables cli","title":"CLI"},{"location":"reference/cruft/cli/#module-cruftcli","text":"This module defines CLI interaction when using cruft . This is powered by hug which means unless necessary it should maintain 1:1 compatibility with the programmatic API definition in the API module cruft create : Expands the specified Cookiecutter template on disk. cruft check : Checks to see if the expanded template is up-to-date with latest version. cruft update : Attempts to updates an expanded Cookiecutter template to the latest version. View Source \"\"\"This module defines CLI interaction when using `cruft`. This is powered by [hug](https://github.com/hugapi/hug) which means unless necessary it should maintain 1:1 compatibility with the programmatic API definition in the [API module](/reference/cruft/api) - `cruft create`: Expands the specified Cookiecutter template on disk. - `cruft check`: Checks to see if the expanded template is up-to-date with latest version. - `cruft update`: Attempts to updates an expanded Cookiecutter template to the latest version. \"\"\" import sys import hug from cruft import api , logo def _check_command_output ( up_to_date : bool ) -> None : if not up_to_date : print ( \"\" ) sys . exit ( \"FAILURE: Project's cruft is out of date! Run `cruft update` to clean this mess up.\" ) else : print ( \"\" ) print ( \"SUCCESS: Good work! Project's cruft is up to date and as clean as possible :).\" ) def _update_output ( updated : bool ) -> None : if not updated : print ( \"\" ) print ( \"Nothing to do, project's cruft is already up to date!\" ) else : print ( \"\" ) print ( \"Good work! Project's cruft has been updated and is as clean as possible!\" ) def _link_output ( linked : bool ) -> None : if linked : print ( \"\" ) print ( \"Project successfully linked to template!\" ) else : print ( \"\" ) print ( \"Project linking failed :(\" ) cli = hug . cli ( api = hug . API ( __name__ , doc = logo . ascii_art )) cli ( api . create ) cli . output ( _update_output )( api . update ) cli . output ( _check_command_output )( api . check ) cli . output ( _link_output )( api . link )","title":"Module cruft.cli"},{"location":"reference/cruft/cli/#variables","text":"cli","title":"Variables"},{"location":"reference/cruft/exceptions/","text":"Module cruft.exceptions Contains all custom exceptions raised by cruft View Source \"\"\" Contains all custom exceptions raised by cruft \"\"\" class CruftError ( Exception ) : \"\"\" The base exception for any error originating from the cruft project \"\"\" class UnableToFindCookiecutterTemplate ( CruftError ) : \"\"\" Raised when Cruft is unable to find a cookiecutter template \"\"\" def __init__ ( self , directory : str ) : super () . __init__ ( self , f \" Was unable to locate a Cookiecutter template in `{directory}` ! \" ) self . directory = directory class NoCruftFound ( CruftError ) : \"\"\" Raised when no .cruft.json state is found in the current directory \"\"\" def __init__ ( self , directory : str ) : super () . __init__ ( self , f \" Was unable to locate a `.cruft.json` state file in `{directory}` ! \" ) self . directory = directory class CruftAlreadyPresent ( CruftError ) : \"\"\" Raised when there is an attempt to create a new .cruft.json file but one already exists \"\"\" def __init__ ( self , file_location : str ) : super () . __init__ ( self , f \" `.cruft.json` is already defined at `{file_location}` ! \" ) self . file_location = file_location class InvalidCookiecutterRepository ( CruftError ) : \"\"\" Raised when an invalid cookiecutter repository is provided \"\"\" pass Classes CruftAlreadyPresent class CruftAlreadyPresent ( file_location : str ) Raised when there is an attempt to create a new .cruft.json file but one already exists View Source class CruftAlreadyPresent ( CruftError ): \"\"\"Raised when there is an attempt to create a new .cruft.json file but one already exists\"\"\" def __init__ ( self , file_location: str ): super (). __init__ ( self , f \"`.cruft.json` is already defined at `{file_location}` !\" ) self . file_location = file_location Ancestors (in MRO) cruft.exceptions.CruftError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. CruftError class CruftError ( / , * args , ** kwargs ) The base exception for any error originating from the cruft project View Source class CruftError ( Exception ) : \"\"\" The base exception for any error originating from the cruft project \"\"\" Ancestors (in MRO) builtins.Exception builtins.BaseException Descendants cruft.exceptions.UnableToFindCookiecutterTemplate cruft.exceptions.NoCruftFound cruft.exceptions.CruftAlreadyPresent cruft.exceptions.InvalidCookiecutterRepository Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. InvalidCookiecutterRepository class InvalidCookiecutterRepository ( / , * args , ** kwargs ) Raised when an invalid cookiecutter repository is provided View Source class InvalidCookiecutterRepository ( CruftError ): \"\"\"Raised when an invalid cookiecutter repository is provided\"\"\" pass Ancestors (in MRO) cruft.exceptions.CruftError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. NoCruftFound class NoCruftFound ( directory : str ) Raised when no .cruft.json state is found in the current directory View Source class NoCruftFound ( CruftError ): \"\"\"Raised when no .cruft.json state is found in the current directory\"\"\" def __init__ ( self , directory: str ): super (). __init__ ( self , f \"Was unable to locate a `.cruft.json` state file in `{directory}` !\" ) self . directory = directory Ancestors (in MRO) cruft.exceptions.CruftError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. UnableToFindCookiecutterTemplate class UnableToFindCookiecutterTemplate ( directory : str ) Raised when Cruft is unable to find a cookiecutter template View Source class UnableToFindCookiecutterTemplate ( CruftError ): \"\"\"Raised when Cruft is unable to find a cookiecutter template\"\"\" def __init__ ( self , directory: str ): super (). __init__ ( self , f \"Was unable to locate a Cookiecutter template in `{directory}` !\" ) self . directory = directory Ancestors (in MRO) cruft.exceptions.CruftError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Exceptions"},{"location":"reference/cruft/exceptions/#module-cruftexceptions","text":"Contains all custom exceptions raised by cruft View Source \"\"\" Contains all custom exceptions raised by cruft \"\"\" class CruftError ( Exception ) : \"\"\" The base exception for any error originating from the cruft project \"\"\" class UnableToFindCookiecutterTemplate ( CruftError ) : \"\"\" Raised when Cruft is unable to find a cookiecutter template \"\"\" def __init__ ( self , directory : str ) : super () . __init__ ( self , f \" Was unable to locate a Cookiecutter template in `{directory}` ! \" ) self . directory = directory class NoCruftFound ( CruftError ) : \"\"\" Raised when no .cruft.json state is found in the current directory \"\"\" def __init__ ( self , directory : str ) : super () . __init__ ( self , f \" Was unable to locate a `.cruft.json` state file in `{directory}` ! \" ) self . directory = directory class CruftAlreadyPresent ( CruftError ) : \"\"\" Raised when there is an attempt to create a new .cruft.json file but one already exists \"\"\" def __init__ ( self , file_location : str ) : super () . __init__ ( self , f \" `.cruft.json` is already defined at `{file_location}` ! \" ) self . file_location = file_location class InvalidCookiecutterRepository ( CruftError ) : \"\"\" Raised when an invalid cookiecutter repository is provided \"\"\" pass","title":"Module cruft.exceptions"},{"location":"reference/cruft/exceptions/#classes","text":"","title":"Classes"},{"location":"reference/cruft/exceptions/#cruftalreadypresent","text":"class CruftAlreadyPresent ( file_location : str ) Raised when there is an attempt to create a new .cruft.json file but one already exists View Source class CruftAlreadyPresent ( CruftError ): \"\"\"Raised when there is an attempt to create a new .cruft.json file but one already exists\"\"\" def __init__ ( self , file_location: str ): super (). __init__ ( self , f \"`.cruft.json` is already defined at `{file_location}` !\" ) self . file_location = file_location","title":"CruftAlreadyPresent"},{"location":"reference/cruft/exceptions/#ancestors-in-mro","text":"cruft.exceptions.CruftError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/cruft/exceptions/#class-variables","text":"args","title":"Class variables"},{"location":"reference/cruft/exceptions/#methods","text":"","title":"Methods"},{"location":"reference/cruft/exceptions/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/cruft/exceptions/#crufterror","text":"class CruftError ( / , * args , ** kwargs ) The base exception for any error originating from the cruft project View Source class CruftError ( Exception ) : \"\"\" The base exception for any error originating from the cruft project \"\"\"","title":"CruftError"},{"location":"reference/cruft/exceptions/#ancestors-in-mro_1","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/cruft/exceptions/#descendants","text":"cruft.exceptions.UnableToFindCookiecutterTemplate cruft.exceptions.NoCruftFound cruft.exceptions.CruftAlreadyPresent cruft.exceptions.InvalidCookiecutterRepository","title":"Descendants"},{"location":"reference/cruft/exceptions/#class-variables_1","text":"args","title":"Class variables"},{"location":"reference/cruft/exceptions/#methods_1","text":"","title":"Methods"},{"location":"reference/cruft/exceptions/#with_traceback_1","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/cruft/exceptions/#invalidcookiecutterrepository","text":"class InvalidCookiecutterRepository ( / , * args , ** kwargs ) Raised when an invalid cookiecutter repository is provided View Source class InvalidCookiecutterRepository ( CruftError ): \"\"\"Raised when an invalid cookiecutter repository is provided\"\"\" pass","title":"InvalidCookiecutterRepository"},{"location":"reference/cruft/exceptions/#ancestors-in-mro_2","text":"cruft.exceptions.CruftError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/cruft/exceptions/#class-variables_2","text":"args","title":"Class variables"},{"location":"reference/cruft/exceptions/#methods_2","text":"","title":"Methods"},{"location":"reference/cruft/exceptions/#with_traceback_2","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/cruft/exceptions/#nocruftfound","text":"class NoCruftFound ( directory : str ) Raised when no .cruft.json state is found in the current directory View Source class NoCruftFound ( CruftError ): \"\"\"Raised when no .cruft.json state is found in the current directory\"\"\" def __init__ ( self , directory: str ): super (). __init__ ( self , f \"Was unable to locate a `.cruft.json` state file in `{directory}` !\" ) self . directory = directory","title":"NoCruftFound"},{"location":"reference/cruft/exceptions/#ancestors-in-mro_3","text":"cruft.exceptions.CruftError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/cruft/exceptions/#class-variables_3","text":"args","title":"Class variables"},{"location":"reference/cruft/exceptions/#methods_3","text":"","title":"Methods"},{"location":"reference/cruft/exceptions/#with_traceback_3","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/cruft/exceptions/#unabletofindcookiecuttertemplate","text":"class UnableToFindCookiecutterTemplate ( directory : str ) Raised when Cruft is unable to find a cookiecutter template View Source class UnableToFindCookiecutterTemplate ( CruftError ): \"\"\"Raised when Cruft is unable to find a cookiecutter template\"\"\" def __init__ ( self , directory: str ): super (). __init__ ( self , f \"Was unable to locate a Cookiecutter template in `{directory}` !\" ) self . directory = directory","title":"UnableToFindCookiecutterTemplate"},{"location":"reference/cruft/exceptions/#ancestors-in-mro_4","text":"cruft.exceptions.CruftError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/cruft/exceptions/#class-variables_4","text":"args","title":"Class variables"},{"location":"reference/cruft/exceptions/#methods_4","text":"","title":"Methods"},{"location":"reference/cruft/exceptions/#with_traceback_4","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/cruft/logo/","text":"Module cruft.logo __________________________________________________ / \\\\\\\\\\ _______________ ________________________________________________ / \\\\\\ /// ________________ _______________________________________________ / \\\\\\ __________ / \\\\\\ ______ _____ / \\\\\\\\\\\\\\\\ __ / \\\\ / \\\\\\\\\\\\\\ ___ / \\\\\\ ____ / \\\\\\ __ / \\\\\\\\\\\\\\\\\\ ____ / \\\\\\\\\\\\\\\\\\\\\\ _ ___ / \\\\\\ ////// __ \\ / \\\\\\ ///// \\\\\\ _ \\ / \\\\\\ ___ \\ / \\\\\\ _ \\ //// \\\\\\ // ____ \\ //// \\\\\\ //// __ __ / \\\\\\ _________ \\ / \\\\\\ ___ \\ /// __ \\ / \\\\\\ ___ \\ / \\\\\\ ____ \\ / \\\\\\ _________ \\ / \\\\\\ ______ _ \\ // \\\\\\ ________ \\ / \\\\\\ _________ \\ / \\\\\\ ___ \\ / \\\\\\ ____ \\ / \\\\\\ _________ \\ / \\\\\\ _ / \\\\ __ __ \\ /// \\\\\\\\\\\\\\\\ _ \\ / \\\\\\ _________ \\ // \\\\\\\\\\\\\\\\\\ _____ \\ / \\\\\\ _________ \\ // \\\\\\\\\\ ___ ____ \\ //////// __ \\ /// ___________ \\ ///////// ______ \\ /// ___________ \\ ///// ____ If you need the boilerplate , at least let cruft manage it . Version : 1.1 . 0 Copyright Timothy Edmund Crosley 2019 MIT License View Source from cruft._version import __version__ ascii_art = rf \"\"\" __________________________________________________/ \\\\\\\\ \\_______________ ________________________________________________/ \\\\ \\///________________ _______________________________________________/ \\\\ \\__________/ \\\\ \\______ _____/ \\\\\\\\\\\\\\\\ __/ \\\\ / \\\\\\\\\\\\ \\___/ \\\\ \\____/ \\\\ \\__/ \\\\\\\\\\\\\\\\ \\____/ \\\\\\\\\\\\\\\\\\\\ \\_ ___/ \\\\ \\//////__\\/ \\\\ \\///// \\\\ \\_\\/ \\\\ \\___\\/ \\\\ \\_\\//// \\\\ \\//____\\//// \\\\ \\////__ __/ \\\\ \\_________\\/ \\\\ \\___\\///__\\/ \\\\ \\___\\/ \\\\ \\____\\/ \\\\ \\_________\\/ \\\\ \\______ _\\// \\\\ \\________\\/ \\\\ \\_________\\/ \\\\ \\___\\/ \\\\ \\____\\/ \\\\ \\_________\\/ \\\\ \\_/ \\\\ __ __\\/// \\\\\\\\\\\\\\\\ _\\/ \\\\ \\_________\\// \\\\\\\\\\\\\\\\ \\_____\\/ \\\\ \\_________\\// \\\\\\\\ \\___ ____\\////////__\\///___________\\/////////______\\///___________\\/////____ If you need the boilerplate, at least let cruft manage it. Version: {__version__} Copyright Timothy Edmund Crosley 2019 MIT License \"\"\" __doc__ = f \"\"\" ```python {ascii_art} ``` \"\"\" Variables ascii_art","title":"Logo"},{"location":"reference/cruft/logo/#module-cruftlogo","text":"__________________________________________________ / \\\\\\\\\\ _______________ ________________________________________________ / \\\\\\ /// ________________ _______________________________________________ / \\\\\\ __________ / \\\\\\ ______ _____ / \\\\\\\\\\\\\\\\ __ / \\\\ / \\\\\\\\\\\\\\ ___ / \\\\\\ ____ / \\\\\\ __ / \\\\\\\\\\\\\\\\\\ ____ / \\\\\\\\\\\\\\\\\\\\\\ _ ___ / \\\\\\ ////// __ \\ / \\\\\\ ///// \\\\\\ _ \\ / \\\\\\ ___ \\ / \\\\\\ _ \\ //// \\\\\\ // ____ \\ //// \\\\\\ //// __ __ / \\\\\\ _________ \\ / \\\\\\ ___ \\ /// __ \\ / \\\\\\ ___ \\ / \\\\\\ ____ \\ / \\\\\\ _________ \\ / \\\\\\ ______ _ \\ // \\\\\\ ________ \\ / \\\\\\ _________ \\ / \\\\\\ ___ \\ / \\\\\\ ____ \\ / \\\\\\ _________ \\ / \\\\\\ _ / \\\\ __ __ \\ /// \\\\\\\\\\\\\\\\ _ \\ / \\\\\\ _________ \\ // \\\\\\\\\\\\\\\\\\ _____ \\ / \\\\\\ _________ \\ // \\\\\\\\\\ ___ ____ \\ //////// __ \\ /// ___________ \\ ///////// ______ \\ /// ___________ \\ ///// ____ If you need the boilerplate , at least let cruft manage it . Version : 1.1 . 0 Copyright Timothy Edmund Crosley 2019 MIT License View Source from cruft._version import __version__ ascii_art = rf \"\"\" __________________________________________________/ \\\\\\\\ \\_______________ ________________________________________________/ \\\\ \\///________________ _______________________________________________/ \\\\ \\__________/ \\\\ \\______ _____/ \\\\\\\\\\\\\\\\ __/ \\\\ / \\\\\\\\\\\\ \\___/ \\\\ \\____/ \\\\ \\__/ \\\\\\\\\\\\\\\\ \\____/ \\\\\\\\\\\\\\\\\\\\ \\_ ___/ \\\\ \\//////__\\/ \\\\ \\///// \\\\ \\_\\/ \\\\ \\___\\/ \\\\ \\_\\//// \\\\ \\//____\\//// \\\\ \\////__ __/ \\\\ \\_________\\/ \\\\ \\___\\///__\\/ \\\\ \\___\\/ \\\\ \\____\\/ \\\\ \\_________\\/ \\\\ \\______ _\\// \\\\ \\________\\/ \\\\ \\_________\\/ \\\\ \\___\\/ \\\\ \\____\\/ \\\\ \\_________\\/ \\\\ \\_/ \\\\ __ __\\/// \\\\\\\\\\\\\\\\ _\\/ \\\\ \\_________\\// \\\\\\\\\\\\\\\\ \\_____\\/ \\\\ \\_________\\// \\\\\\\\ \\___ ____\\////////__\\///___________\\/////////______\\///___________\\/////____ If you need the boilerplate, at least let cruft manage it. Version: {__version__} Copyright Timothy Edmund Crosley 2019 MIT License \"\"\" __doc__ = f \"\"\" ```python {ascii_art} ``` \"\"\"","title":"Module cruft.logo"},{"location":"reference/cruft/logo/#variables","text":"ascii_art","title":"Variables"}]}