{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Read Latest Documentation - Browse GitHub Code Repository cruft Allows you to maintain all the necessary cruft for packaging and building projects separate from the code you intentionally write. Built on-top of CookieCutter.","title":"Home"},{"location":"CHANGELOG/","text":"Install the latest To install the latest version of cruft simply run: pip3 install cruft OR poetry add cruft OR pipenv install cruft Changelog 1.0.0 - TBD Initial API stable release.","title":"Changelog"},{"location":"CHANGELOG/#install-the-latest","text":"To install the latest version of cruft simply run: pip3 install cruft OR poetry add cruft OR pipenv install cruft","title":"Install the latest"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#100-tbd","text":"Initial API stable release.","title":"1.0.0 - TBD"},{"location":"docs/contributing/1.-contributing-guide/","text":"Contributing to cruft Looking for a useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Welcome! You have found the right place. Getting cruft set up for local development The first step when contributing to any project is getting it set up on your local machine. cruft aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.6+ poetry bash or a bash compatible shell (should be auto-installed on Linux / Mac) Once you have verified that you system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/cruft.git `cd cruft poetry install Making a contribution Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. If you're not sure if it's something that is good for the main cruft project and want immediate feedback, you can discuss it here . Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Ensure your code matches the HOPE-8 Coding Standard used by the project. Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the acknowledgments list :). Thank you! I can not tell you how thankful I am for the hard work done by cruft contributors like you . Thank you! ~Timothy Crosley","title":"1. Contributing Guide"},{"location":"docs/contributing/1.-contributing-guide/#contributing-to-cruft","text":"Looking for a useful open source project to contribute to? Want your contributions to be warmly welcomed and acknowledged? Welcome! You have found the right place.","title":"Contributing to cruft"},{"location":"docs/contributing/1.-contributing-guide/#getting-cruft-set-up-for-local-development","text":"The first step when contributing to any project is getting it set up on your local machine. cruft aims to make this as simple as possible. Account Requirements: A valid GitHub account Base System Requirements: Python3.6+ poetry bash or a bash compatible shell (should be auto-installed on Linux / Mac) Once you have verified that you system matches the base requirements you can start to get the project working by following these steps: Fork the project on GitHub . Clone your fork to your local file system: git clone https://github.com/$GITHUB_ACCOUNT/cruft.git `cd cruft poetry install","title":"Getting cruft set up for local development"},{"location":"docs/contributing/1.-contributing-guide/#making-a-contribution","text":"Congrats! You're now ready to make a contribution! Use the following as a guide to help you reach a successful pull-request: Check the issues page on GitHub to see if the task you want to complete is listed there. If it's listed there, write a comment letting others know you are working on it. If it's not listed in GitHub issues, go ahead and log a new issue. Then add a comment letting everyone know you have it under control. If you're not sure if it's something that is good for the main cruft project and want immediate feedback, you can discuss it here . Create an issue branch for your local work git checkout -b issue/$ISSUE-NUMBER . Do your magic here. Ensure your code matches the HOPE-8 Coding Standard used by the project. Submit a pull request to the main project repository via GitHub. Thanks for the contribution! It will quickly get reviewed, and, once accepted, will result in your name being added to the acknowledgments list :).","title":"Making a contribution"},{"location":"docs/contributing/1.-contributing-guide/#thank-you","text":"I can not tell you how thankful I am for the hard work done by cruft contributors like you . Thank you! ~Timothy Crosley","title":"Thank you!"},{"location":"docs/contributing/2.-coding-standard/","text":"HOPE 8 -- Style Guide for Hug Code HOPE: 8 Title: Style Guide for Hug Code Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 19-May-2019 Updated: 17-August-2019 Introduction This document gives coding conventions for the Hug code comprising the Hug core as well as all official interfaces, extensions, and plugins for the framework. Optionally, projects that use Hug are encouraged to follow this HOPE and link to it as a reference. PEP 8 Foundation All guidelines in this document are in addition to those defined in Python's PEP 8 and PEP 257 guidelines. Line Length Too short of lines discourage descriptive variable names where they otherwise make sense. Too long of lines reduce overall readability and make it hard to compare 2 files side by side. There is no perfect number: but for Hug, we've decided to cap the lines at 100 characters. Descriptive Variable names Naming things is hard. Hug has a few strict guidelines on the usage of variable names, which hopefully will reduce some of the guesswork: - No one character variable names. - Except for x, y, and z as coordinates. - It's not okay to override built-in functions. - Except for id . Guido himself thought that shouldn't have been moved to the system module. It's too commonly used, and alternatives feel very artificial. - Avoid Acronyms, Abbreviations, or any other short forms - unless they are almost universally understand. Adding new modules New modules added to the a project that follows the HOPE-8 standard should all live directly within the base PROJECT_NAME/ directory without nesting. If the modules are meant only for internal use within the project, they should be prefixed with a leading underscore. For example, def _internal_function. Modules should contain a docstring at the top that gives a general explanation of the purpose and then restates the project's use of the MIT license. There should be a tests/test_$MODULE_NAME.py file created to correspond to every new module that contains test coverage for the module. Ideally, tests should be 1:1 (one test object per code object, one test method per code method) to the extent cleanly possible. Automated Code Cleaners All code submitted to Hug should be formatted using Black and isort. Black should be run with the line length set to 100, and isort with Black compatible settings in place. Automated Code Linting All code submitted to hug should run through the following tools: Black and isort verification. Flake8 flake8-bugbear Bandit pep8-naming vulture safety","title":"2. Coding Standard"},{"location":"docs/contributing/2.-coding-standard/#hope-8-style-guide-for-hug-code","text":"HOPE: 8 Title: Style Guide for Hug Code Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 19-May-2019 Updated: 17-August-2019","title":"HOPE 8 -- Style Guide for Hug Code"},{"location":"docs/contributing/2.-coding-standard/#introduction","text":"This document gives coding conventions for the Hug code comprising the Hug core as well as all official interfaces, extensions, and plugins for the framework. Optionally, projects that use Hug are encouraged to follow this HOPE and link to it as a reference.","title":"Introduction"},{"location":"docs/contributing/2.-coding-standard/#pep-8-foundation","text":"All guidelines in this document are in addition to those defined in Python's PEP 8 and PEP 257 guidelines.","title":"PEP 8 Foundation"},{"location":"docs/contributing/2.-coding-standard/#line-length","text":"Too short of lines discourage descriptive variable names where they otherwise make sense. Too long of lines reduce overall readability and make it hard to compare 2 files side by side. There is no perfect number: but for Hug, we've decided to cap the lines at 100 characters.","title":"Line Length"},{"location":"docs/contributing/2.-coding-standard/#descriptive-variable-names","text":"Naming things is hard. Hug has a few strict guidelines on the usage of variable names, which hopefully will reduce some of the guesswork: - No one character variable names. - Except for x, y, and z as coordinates. - It's not okay to override built-in functions. - Except for id . Guido himself thought that shouldn't have been moved to the system module. It's too commonly used, and alternatives feel very artificial. - Avoid Acronyms, Abbreviations, or any other short forms - unless they are almost universally understand.","title":"Descriptive Variable names"},{"location":"docs/contributing/2.-coding-standard/#adding-new-modules","text":"New modules added to the a project that follows the HOPE-8 standard should all live directly within the base PROJECT_NAME/ directory without nesting. If the modules are meant only for internal use within the project, they should be prefixed with a leading underscore. For example, def _internal_function. Modules should contain a docstring at the top that gives a general explanation of the purpose and then restates the project's use of the MIT license. There should be a tests/test_$MODULE_NAME.py file created to correspond to every new module that contains test coverage for the module. Ideally, tests should be 1:1 (one test object per code object, one test method per code method) to the extent cleanly possible.","title":"Adding new modules"},{"location":"docs/contributing/2.-coding-standard/#automated-code-cleaners","text":"All code submitted to Hug should be formatted using Black and isort. Black should be run with the line length set to 100, and isort with Black compatible settings in place.","title":"Automated Code Cleaners"},{"location":"docs/contributing/2.-coding-standard/#automated-code-linting","text":"All code submitted to hug should run through the following tools: Black and isort verification. Flake8 flake8-bugbear Bandit pep8-naming vulture safety","title":"Automated Code Linting"},{"location":"docs/contributing/3.-code-of-conduct/","text":"HOPE 11 -- Code of Conduct HOPE: 11 Title: Code of Conduct Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 17-August-2019 Updated: 17-August-2019 Abstract Defines the Code of Conduct for Hug and all related projects. Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting timothy.crosley@gmail.com . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Confidentiality will be maintained with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the [Contributor Covenant][https://www.contributor-covenant.org], version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"3. Code Of Conduct"},{"location":"docs/contributing/3.-code-of-conduct/#hope-11-code-of-conduct","text":"HOPE: 11 Title: Code of Conduct Author(s): Timothy Crosley timothy.crosley@gmail.com Status: Active Type: Process Created: 17-August-2019 Updated: 17-August-2019","title":"HOPE 11 -- Code of Conduct"},{"location":"docs/contributing/3.-code-of-conduct/#abstract","text":"Defines the Code of Conduct for Hug and all related projects.","title":"Abstract"},{"location":"docs/contributing/3.-code-of-conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"docs/contributing/3.-code-of-conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"docs/contributing/3.-code-of-conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"docs/contributing/3.-code-of-conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"docs/contributing/3.-code-of-conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting timothy.crosley@gmail.com . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Confidentiality will be maintained with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"docs/contributing/3.-code-of-conduct/#attribution","text":"This Code of Conduct is adapted from the [Contributor Covenant][https://www.contributor-covenant.org], version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"docs/contributing/4.-acknowledgements/","text":"Contributors Core Developers Timothy Crosley (@timothycrosley) Notable Bug Reporters - Code Contributors - Documenters - A sincere thanks to everyone who helps make cruft into a great Python3 project! ~Timothy Crosley","title":"4. Acknowledgements"},{"location":"docs/contributing/4.-acknowledgements/#contributors","text":"","title":"Contributors"},{"location":"docs/contributing/4.-acknowledgements/#core-developers","text":"Timothy Crosley (@timothycrosley)","title":"Core Developers"},{"location":"docs/contributing/4.-acknowledgements/#notable-bug-reporters","text":"-","title":"Notable Bug Reporters"},{"location":"docs/contributing/4.-acknowledgements/#code-contributors","text":"-","title":"Code Contributors"},{"location":"docs/contributing/4.-acknowledgements/#documenters","text":"- A sincere thanks to everyone who helps make cruft into a great Python3 project! ~Timothy Crosley","title":"Documenters"},{"location":"reference/cruft/","text":"Module cruft cruft Allows you to maintain all the necessary cruft for packaging and building projects separate from the code you intentionally write. Built on-top of, and fully compatible with, CookieCutter. View Source \"\"\"**cruft** Allows you to maintain all the necessary cruft for packaging and building projects separate from the code you intentionally write. Built on-top of, and fully compatible with, CookieCutter. \"\"\" from cruft._version import __version__ Sub-modules cruft.api cruft.cli cruft.exceptions cruft.logo","title":"Index"},{"location":"reference/cruft/#module-cruft","text":"cruft Allows you to maintain all the necessary cruft for packaging and building projects separate from the code you intentionally write. Built on-top of, and fully compatible with, CookieCutter. View Source \"\"\"**cruft** Allows you to maintain all the necessary cruft for packaging and building projects separate from the code you intentionally write. Built on-top of, and fully compatible with, CookieCutter. \"\"\" from cruft._version import __version__","title":"Module cruft"},{"location":"reference/cruft/#sub-modules","text":"cruft.api cruft.cli cruft.exceptions cruft.logo","title":"Sub-modules"},{"location":"reference/cruft/api/","text":"Module cruft.api View Source import json import os import sys from functools import partial from pathlib import Path from shutil import move from subprocess import run # nosec from tempfile import TemporaryDirectory from typing import Optional from cookiecutter.config import get_user_config from cookiecutter.generate import generate_context , generate_files from cookiecutter.prompt import prompt_for_config from examples import example from git import Repo from cruft.exceptions import NoCruftFound , UnableToFindCookiecutterTemplate json_dump = partial ( json . dump , ensure_ascii = False , indent = 4 , separators = ( \",\" , \": \" )) @example ( \"https://github.com/timothycrosley/cookiecutter-python/\" , no_input = True ) def create ( template_git_url : str , output_dir : str = \".\" , config_file : Optional [ str ] = None , default_config : bool = False , extra_context : Optional [ dict ] = None , no_input : bool = False , overwrite_if_exists : bool = False , ) -> str : \"\"\"Expand a Git based Cookiecutter template into a new project on disk.\"\"\" with TemporaryDirectory () as cookiecutter_template_dir : repo = Repo . clone_from ( template_git_url , cookiecutter_template_dir ) last_commit = repo . head . object . hexsha main_cookiecutter_directory : str = \"\" for file_name in os . listdir ( cookiecutter_template_dir ): file_path = os . path . join ( cookiecutter_template_dir , file_name ) if ( os . path . isdir ( file_path ) and \"{{\" in file_name and \"}}\" in file_name and \"cookiecutter.\" in file_name ): main_cookiecutter_directory = file_path break if not main_cookiecutter_directory : raise UnableToFindCookiecutterTemplate ( cookiecutter_template_dir ) context_file = os . path . join ( cookiecutter_template_dir , \"cookiecutter.json\" ) config_dict = get_user_config ( config_file = config_file , default_config = default_config ) context = generate_context ( context_file = context_file , default_context = config_dict [ \"default_context\" ], extra_context = extra_context , ) # prompt the user to manually configure at the command line. # except when 'no-input' flag is set context [ \"cookiecutter\" ] = prompt_for_config ( context , no_input ) context [ \"cookiecutter\" ][ \"_template\" ] = template_git_url with open ( os . path . join ( main_cookiecutter_directory , \".cruft.json\" ), \"w\" ) as cruft_file : json_dump ( { \"template\" : template_git_url , \"commit\" : last_commit , \"context\" : context }, cruft_file , ) return generate_files ( repo_dir = cookiecutter_template_dir , context = context , overwrite_if_exists = overwrite_if_exists , output_dir = output_dir , ) def check ( expanded_dir : str = \".\" ) -> bool : \"\"\"Checks to see if there have been any updates to the Cookiecutter template used to generate this project. \"\"\" cruft_file = os . path . join ( expanded_dir , \".cruft.json\" ) if not os . path . isfile ( cruft_file ): raise NoCruftFound ( os . path . abspath ( expanded_dir )) with open ( cruft_file ) as cruft_open_file : cruft_state = json . load ( cruft_open_file ) with TemporaryDirectory () as cookiecutter_template_dir : repo = Repo . clone_from ( cruft_state [ \"template\" ], cookiecutter_template_dir ) last_commit = repo . head . object . hexsha if last_commit == cruft_state [ \"commit\" ] or not repo . index . diff ( cruft_state [ \"commit\" ]): return True return False def _generate_output ( context_file : str , cruft_state : dict , cookiecutter_input : bool , template_dir : str , output_dir : str , ) -> dict : context = generate_context ( context_file = context_file , extra_context = cruft_state [ \"context\" ][ \"cookiecutter\" ] ) context [ \"cookiecutter\" ] = prompt_for_config ( context , not cookiecutter_input ) context [ \"cookiecutter\" ][ \"_template\" ] = cruft_state [ \"template\" ] generate_files ( repo_dir = template_dir , context = context , overwrite_if_exists = True , output_dir = output_dir ) return context def update ( expanded_dir : str = \".\" , cookiecutter_input : bool = False , skip_apply_ask : bool = False ) -> bool : \"\"\"Update specified project's cruft to the latest and greatest release.\"\"\" cruft_file = os . path . join ( expanded_dir , \".cruft.json\" ) if not os . path . isfile ( cruft_file ): raise NoCruftFound ( os . path . abspath ( expanded_dir )) with open ( cruft_file ) as cruft_open_file : cruft_state = json . load ( cruft_open_file ) with TemporaryDirectory () as compare_directory : template_dir = os . path . join ( compare_directory , \"template\" ) repo = Repo . clone_from ( cruft_state [ \"template\" ], template_dir ) last_commit = repo . head . object . hexsha if last_commit == cruft_state [ \"commit\" ] or not repo . index . diff ( cruft_state [ \"commit\" ]): return False context_file = os . path . join ( template_dir , \"cookiecutter.json\" ) new_output_dir = os . path . join ( compare_directory , \"new_output\" ) new_context = _generate_output ( context_file = context_file , cruft_state = cruft_state , cookiecutter_input = cookiecutter_input , template_dir = template_dir , output_dir = new_output_dir , ) old_output_dir = os . path . join ( compare_directory , \"old_output\" ) repo . head . reset ( commit = cruft_state [ \"commit\" ], working_tree = True ) _generate_output ( context_file = context_file , cruft_state = cruft_state , cookiecutter_input = cookiecutter_input , template_dir = template_dir , output_dir = old_output_dir , ) main_directory : str = \"\" for file_name in os . listdir ( old_output_dir ): file_path = os . path . join ( old_output_dir , file_name ) if os . path . isdir ( file_path ): main_directory = file_name new_main_directory = os . path . join ( new_output_dir , main_directory ) old_main_directory = os . path . join ( old_output_dir , main_directory ) diff = run ( [ \"git\" , \"diff\" , old_main_directory , new_main_directory ], capture_output = True ) . stdout . decode ( \"utf8\" ) diff = diff . replace ( old_main_directory , \"\" ) . replace ( new_main_directory , \"\" ) print ( \"The following diff would be applied: \\n \" ) print ( diff ) print ( \"\" ) if not skip_apply_ask : update = \"\" while update . lower () not in ( \"y\" , \"n\" ): update = input ( \"Apply diff and update [y/n]? \" ) # nosec if update . lower () == \"n\" : sys . exit ( \"User cancelled Cookiecutter template update.\" ) current_directory = os . getcwd () try : os . chdir ( expanded_dir ) run ([ \"git\" , \"apply\" ], input = diff . encode ( \"utf8\" )) cruft_state [ \"commit\" ] = last_commit cruft_state [ \"context\" ] = new_context with open ( cruft_file , \"w\" ) as cruft_output : json_dump ( cruft_state , cruft_output ) finally : os . chdir ( current_directory ) return True Variables json_dump Functions check def check ( expanded_dir : str = '.' ) -> bool Checks to see if there have been any updates to the Cookiecutter template used to generate this project. View Source def check ( expanded_dir : str = \" . \" ) -> bool : \"\"\" Checks to see if there have been any updates to the Cookiecutter template used to generate this project . \"\"\" cruft_file = os . path . join ( expanded_dir , \" .cruft.json \" ) if not os . path . isfile ( cruft_file ) : raise NoCruftFound ( os . path . abspath ( expanded_dir )) with open ( cruft_file ) as cruft_open_file : cruft_state = json . load ( cruft_open_file ) with TemporaryDirectory () as cookiecutter_template_dir : repo = Repo . clone_from ( cruft_state [ \" template \" ], cookiecutter_template_dir ) last_commit = repo . head . object . hexsha if last_commit == cruft_state [ \" commit \" ] or not repo . index . diff ( cruft_state [ \" commit \" ] ) : return True return False create def create ( template_git_url : str , output_dir : str = '.' , config_file : Union [ str , NoneType ] = None , default_config : bool = False , extra_context : Union [ dict , NoneType ] = None , no_input : bool = False , overwrite_if_exists : bool = False ) -> str Expand a Git based Cookiecutter template into a new project on disk. Examples: create ( 'https://github.com/timothycrosley/cookiecutter-python/' , no_input = True ) View Source @ example ( \" https://github.com/timothycrosley/cookiecutter-python/ \" , no_input = True ) def create ( template_git_url : str , output_dir : str = \" . \" , config_file : Optional [ str ] = None , default_config : bool = False , extra_context : Optional [ dict ] = None , no_input : bool = False , overwrite_if_exists : bool = False , ) -> str : \"\"\" Expand a Git based Cookiecutter template into a new project on disk. \"\"\" with TemporaryDirectory () as cookiecutter_template_dir : repo = Repo . clone_from ( template_git_url , cookiecutter_template_dir ) last_commit = repo . head . object . hexsha main_cookiecutter_directory : str = \"\" for file_name in os . listdir ( cookiecutter_template_dir ) : file_path = os . path . join ( cookiecutter_template_dir , file_name ) if ( os . path . isdir ( file_path ) and \" {{ \" in file_name and \" }} \" in file_name and \" cookiecutter. \" in file_name ) : main_cookiecutter_directory = file_path break if not main_cookiecutter_directory : raise UnableToFindCookiecutterTemplate ( cookiecutter_template_dir ) context_file = os . path . join ( cookiecutter_template_dir , \" cookiecutter.json \" ) config_dict = get_user_config ( config_file = config_file , default_config = default_config ) context = generate_context ( context_file = context_file , default_context = config_dict [ \" default_context \" ], extra_context = extra_context , ) # prompt the user to manually configure at the command line . # except when ' no-input ' flag is set context [ \" cookiecutter \" ] = prompt_for_config ( context , no_input ) context [ \" cookiecutter \" ][ \" _template \" ] = template_git_url with open ( os . path . join ( main_cookiecutter_directory , \" .cruft.json \" ) , \" w \" ) as cruft_file : json_dump ( { \" template \" : template_git_url , \" commit \" : last_commit , \" context \" : context }, cruft_file , ) return generate_files ( repo_dir = cookiecutter_template_dir , context = context , overwrite_if_exists = overwrite_if_exists , output_dir = output_dir , ) update def update ( expanded_dir : str = '.' , cookiecutter_input : bool = False , skip_apply_ask : bool = False ) -> bool Update specified project's cruft to the latest and greatest release. View Source def update ( expanded_dir : str = \" . \" , cookiecutter_input : bool = False , skip_apply_ask : bool = False ) -> bool : \"\"\" Update specified project's cruft to the latest and greatest release. \"\"\" cruft_file = os . path . join ( expanded_dir , \" .cruft.json \" ) if not os . path . isfile ( cruft_file ) : raise NoCruftFound ( os . path . abspath ( expanded_dir )) with open ( cruft_file ) as cruft_open_file : cruft_state = json . load ( cruft_open_file ) with TemporaryDirectory () as compare_directory : template_dir = os . path . join ( compare_directory , \" template \" ) repo = Repo . clone_from ( cruft_state [ \" template \" ], template_dir ) last_commit = repo . head . object . hexsha if last_commit == cruft_state [ \" commit \" ] or not repo . index . diff ( cruft_state [ \" commit \" ] ) : return False context_file = os . path . join ( template_dir , \" cookiecutter.json \" ) new_output_dir = os . path . join ( compare_directory , \" new_output \" ) new_context = _generate_output ( context_file = context_file , cruft_state = cruft_state , cookiecutter_input = cookiecutter_input , template_dir = template_dir , output_dir = new_output_dir , ) old_output_dir = os . path . join ( compare_directory , \" old_output \" ) repo . head . reset ( commit = cruft_state [ \" commit \" ], working_tree = True ) _generate_output ( context_file = context_file , cruft_state = cruft_state , cookiecutter_input = cookiecutter_input , template_dir = template_dir , output_dir = old_output_dir , ) main_directory : str = \"\" for file_name in os . listdir ( old_output_dir ) : file_path = os . path . join ( old_output_dir , file_name ) if os . path . isdir ( file_path ) : main_directory = file_name new_main_directory = os . path . join ( new_output_dir , main_directory ) old_main_directory = os . path . join ( old_output_dir , main_directory ) diff = run ( [ \" git \" , \" diff \" , old_main_directory , new_main_directory ], capture_output = True ) . stdout . decode ( \" utf8 \" ) diff = diff . replace ( old_main_directory , \"\" ) . replace ( new_main_directory , \"\" ) print ( \" The following diff would be applied: \\n \" ) print ( diff ) print ( \"\" ) if not skip_apply_ask : update = \"\" while update . lower () not in ( \" y \" , \" n \" ) : update = input ( \" Apply diff and update [y/n]? \" ) # nosec if update . lower () == \" n \" : sys . exit ( \" User cancelled Cookiecutter template update. \" ) current_directory = os . getcwd () try : os . chdir ( expanded_dir ) run ( [ \" git \" , \" apply \" ], input = diff . encode ( \" utf8 \" )) cruft_state [ \" commit \" ] = last_commit cruft_state [ \" context \" ] = new_context with open ( cruft_file , \" w \" ) as cruft_output : json_dump ( cruft_state , cruft_output ) finally : os . chdir ( current_directory ) return True","title":"API"},{"location":"reference/cruft/api/#module-cruftapi","text":"View Source import json import os import sys from functools import partial from pathlib import Path from shutil import move from subprocess import run # nosec from tempfile import TemporaryDirectory from typing import Optional from cookiecutter.config import get_user_config from cookiecutter.generate import generate_context , generate_files from cookiecutter.prompt import prompt_for_config from examples import example from git import Repo from cruft.exceptions import NoCruftFound , UnableToFindCookiecutterTemplate json_dump = partial ( json . dump , ensure_ascii = False , indent = 4 , separators = ( \",\" , \": \" )) @example ( \"https://github.com/timothycrosley/cookiecutter-python/\" , no_input = True ) def create ( template_git_url : str , output_dir : str = \".\" , config_file : Optional [ str ] = None , default_config : bool = False , extra_context : Optional [ dict ] = None , no_input : bool = False , overwrite_if_exists : bool = False , ) -> str : \"\"\"Expand a Git based Cookiecutter template into a new project on disk.\"\"\" with TemporaryDirectory () as cookiecutter_template_dir : repo = Repo . clone_from ( template_git_url , cookiecutter_template_dir ) last_commit = repo . head . object . hexsha main_cookiecutter_directory : str = \"\" for file_name in os . listdir ( cookiecutter_template_dir ): file_path = os . path . join ( cookiecutter_template_dir , file_name ) if ( os . path . isdir ( file_path ) and \"{{\" in file_name and \"}}\" in file_name and \"cookiecutter.\" in file_name ): main_cookiecutter_directory = file_path break if not main_cookiecutter_directory : raise UnableToFindCookiecutterTemplate ( cookiecutter_template_dir ) context_file = os . path . join ( cookiecutter_template_dir , \"cookiecutter.json\" ) config_dict = get_user_config ( config_file = config_file , default_config = default_config ) context = generate_context ( context_file = context_file , default_context = config_dict [ \"default_context\" ], extra_context = extra_context , ) # prompt the user to manually configure at the command line. # except when 'no-input' flag is set context [ \"cookiecutter\" ] = prompt_for_config ( context , no_input ) context [ \"cookiecutter\" ][ \"_template\" ] = template_git_url with open ( os . path . join ( main_cookiecutter_directory , \".cruft.json\" ), \"w\" ) as cruft_file : json_dump ( { \"template\" : template_git_url , \"commit\" : last_commit , \"context\" : context }, cruft_file , ) return generate_files ( repo_dir = cookiecutter_template_dir , context = context , overwrite_if_exists = overwrite_if_exists , output_dir = output_dir , ) def check ( expanded_dir : str = \".\" ) -> bool : \"\"\"Checks to see if there have been any updates to the Cookiecutter template used to generate this project. \"\"\" cruft_file = os . path . join ( expanded_dir , \".cruft.json\" ) if not os . path . isfile ( cruft_file ): raise NoCruftFound ( os . path . abspath ( expanded_dir )) with open ( cruft_file ) as cruft_open_file : cruft_state = json . load ( cruft_open_file ) with TemporaryDirectory () as cookiecutter_template_dir : repo = Repo . clone_from ( cruft_state [ \"template\" ], cookiecutter_template_dir ) last_commit = repo . head . object . hexsha if last_commit == cruft_state [ \"commit\" ] or not repo . index . diff ( cruft_state [ \"commit\" ]): return True return False def _generate_output ( context_file : str , cruft_state : dict , cookiecutter_input : bool , template_dir : str , output_dir : str , ) -> dict : context = generate_context ( context_file = context_file , extra_context = cruft_state [ \"context\" ][ \"cookiecutter\" ] ) context [ \"cookiecutter\" ] = prompt_for_config ( context , not cookiecutter_input ) context [ \"cookiecutter\" ][ \"_template\" ] = cruft_state [ \"template\" ] generate_files ( repo_dir = template_dir , context = context , overwrite_if_exists = True , output_dir = output_dir ) return context def update ( expanded_dir : str = \".\" , cookiecutter_input : bool = False , skip_apply_ask : bool = False ) -> bool : \"\"\"Update specified project's cruft to the latest and greatest release.\"\"\" cruft_file = os . path . join ( expanded_dir , \".cruft.json\" ) if not os . path . isfile ( cruft_file ): raise NoCruftFound ( os . path . abspath ( expanded_dir )) with open ( cruft_file ) as cruft_open_file : cruft_state = json . load ( cruft_open_file ) with TemporaryDirectory () as compare_directory : template_dir = os . path . join ( compare_directory , \"template\" ) repo = Repo . clone_from ( cruft_state [ \"template\" ], template_dir ) last_commit = repo . head . object . hexsha if last_commit == cruft_state [ \"commit\" ] or not repo . index . diff ( cruft_state [ \"commit\" ]): return False context_file = os . path . join ( template_dir , \"cookiecutter.json\" ) new_output_dir = os . path . join ( compare_directory , \"new_output\" ) new_context = _generate_output ( context_file = context_file , cruft_state = cruft_state , cookiecutter_input = cookiecutter_input , template_dir = template_dir , output_dir = new_output_dir , ) old_output_dir = os . path . join ( compare_directory , \"old_output\" ) repo . head . reset ( commit = cruft_state [ \"commit\" ], working_tree = True ) _generate_output ( context_file = context_file , cruft_state = cruft_state , cookiecutter_input = cookiecutter_input , template_dir = template_dir , output_dir = old_output_dir , ) main_directory : str = \"\" for file_name in os . listdir ( old_output_dir ): file_path = os . path . join ( old_output_dir , file_name ) if os . path . isdir ( file_path ): main_directory = file_name new_main_directory = os . path . join ( new_output_dir , main_directory ) old_main_directory = os . path . join ( old_output_dir , main_directory ) diff = run ( [ \"git\" , \"diff\" , old_main_directory , new_main_directory ], capture_output = True ) . stdout . decode ( \"utf8\" ) diff = diff . replace ( old_main_directory , \"\" ) . replace ( new_main_directory , \"\" ) print ( \"The following diff would be applied: \\n \" ) print ( diff ) print ( \"\" ) if not skip_apply_ask : update = \"\" while update . lower () not in ( \"y\" , \"n\" ): update = input ( \"Apply diff and update [y/n]? \" ) # nosec if update . lower () == \"n\" : sys . exit ( \"User cancelled Cookiecutter template update.\" ) current_directory = os . getcwd () try : os . chdir ( expanded_dir ) run ([ \"git\" , \"apply\" ], input = diff . encode ( \"utf8\" )) cruft_state [ \"commit\" ] = last_commit cruft_state [ \"context\" ] = new_context with open ( cruft_file , \"w\" ) as cruft_output : json_dump ( cruft_state , cruft_output ) finally : os . chdir ( current_directory ) return True","title":"Module cruft.api"},{"location":"reference/cruft/api/#variables","text":"json_dump","title":"Variables"},{"location":"reference/cruft/api/#functions","text":"","title":"Functions"},{"location":"reference/cruft/api/#check","text":"def check ( expanded_dir : str = '.' ) -> bool Checks to see if there have been any updates to the Cookiecutter template used to generate this project. View Source def check ( expanded_dir : str = \" . \" ) -> bool : \"\"\" Checks to see if there have been any updates to the Cookiecutter template used to generate this project . \"\"\" cruft_file = os . path . join ( expanded_dir , \" .cruft.json \" ) if not os . path . isfile ( cruft_file ) : raise NoCruftFound ( os . path . abspath ( expanded_dir )) with open ( cruft_file ) as cruft_open_file : cruft_state = json . load ( cruft_open_file ) with TemporaryDirectory () as cookiecutter_template_dir : repo = Repo . clone_from ( cruft_state [ \" template \" ], cookiecutter_template_dir ) last_commit = repo . head . object . hexsha if last_commit == cruft_state [ \" commit \" ] or not repo . index . diff ( cruft_state [ \" commit \" ] ) : return True return False","title":"check"},{"location":"reference/cruft/api/#create","text":"def create ( template_git_url : str , output_dir : str = '.' , config_file : Union [ str , NoneType ] = None , default_config : bool = False , extra_context : Union [ dict , NoneType ] = None , no_input : bool = False , overwrite_if_exists : bool = False ) -> str Expand a Git based Cookiecutter template into a new project on disk. Examples: create ( 'https://github.com/timothycrosley/cookiecutter-python/' , no_input = True ) View Source @ example ( \" https://github.com/timothycrosley/cookiecutter-python/ \" , no_input = True ) def create ( template_git_url : str , output_dir : str = \" . \" , config_file : Optional [ str ] = None , default_config : bool = False , extra_context : Optional [ dict ] = None , no_input : bool = False , overwrite_if_exists : bool = False , ) -> str : \"\"\" Expand a Git based Cookiecutter template into a new project on disk. \"\"\" with TemporaryDirectory () as cookiecutter_template_dir : repo = Repo . clone_from ( template_git_url , cookiecutter_template_dir ) last_commit = repo . head . object . hexsha main_cookiecutter_directory : str = \"\" for file_name in os . listdir ( cookiecutter_template_dir ) : file_path = os . path . join ( cookiecutter_template_dir , file_name ) if ( os . path . isdir ( file_path ) and \" {{ \" in file_name and \" }} \" in file_name and \" cookiecutter. \" in file_name ) : main_cookiecutter_directory = file_path break if not main_cookiecutter_directory : raise UnableToFindCookiecutterTemplate ( cookiecutter_template_dir ) context_file = os . path . join ( cookiecutter_template_dir , \" cookiecutter.json \" ) config_dict = get_user_config ( config_file = config_file , default_config = default_config ) context = generate_context ( context_file = context_file , default_context = config_dict [ \" default_context \" ], extra_context = extra_context , ) # prompt the user to manually configure at the command line . # except when ' no-input ' flag is set context [ \" cookiecutter \" ] = prompt_for_config ( context , no_input ) context [ \" cookiecutter \" ][ \" _template \" ] = template_git_url with open ( os . path . join ( main_cookiecutter_directory , \" .cruft.json \" ) , \" w \" ) as cruft_file : json_dump ( { \" template \" : template_git_url , \" commit \" : last_commit , \" context \" : context }, cruft_file , ) return generate_files ( repo_dir = cookiecutter_template_dir , context = context , overwrite_if_exists = overwrite_if_exists , output_dir = output_dir , )","title":"create"},{"location":"reference/cruft/api/#update","text":"def update ( expanded_dir : str = '.' , cookiecutter_input : bool = False , skip_apply_ask : bool = False ) -> bool Update specified project's cruft to the latest and greatest release. View Source def update ( expanded_dir : str = \" . \" , cookiecutter_input : bool = False , skip_apply_ask : bool = False ) -> bool : \"\"\" Update specified project's cruft to the latest and greatest release. \"\"\" cruft_file = os . path . join ( expanded_dir , \" .cruft.json \" ) if not os . path . isfile ( cruft_file ) : raise NoCruftFound ( os . path . abspath ( expanded_dir )) with open ( cruft_file ) as cruft_open_file : cruft_state = json . load ( cruft_open_file ) with TemporaryDirectory () as compare_directory : template_dir = os . path . join ( compare_directory , \" template \" ) repo = Repo . clone_from ( cruft_state [ \" template \" ], template_dir ) last_commit = repo . head . object . hexsha if last_commit == cruft_state [ \" commit \" ] or not repo . index . diff ( cruft_state [ \" commit \" ] ) : return False context_file = os . path . join ( template_dir , \" cookiecutter.json \" ) new_output_dir = os . path . join ( compare_directory , \" new_output \" ) new_context = _generate_output ( context_file = context_file , cruft_state = cruft_state , cookiecutter_input = cookiecutter_input , template_dir = template_dir , output_dir = new_output_dir , ) old_output_dir = os . path . join ( compare_directory , \" old_output \" ) repo . head . reset ( commit = cruft_state [ \" commit \" ], working_tree = True ) _generate_output ( context_file = context_file , cruft_state = cruft_state , cookiecutter_input = cookiecutter_input , template_dir = template_dir , output_dir = old_output_dir , ) main_directory : str = \"\" for file_name in os . listdir ( old_output_dir ) : file_path = os . path . join ( old_output_dir , file_name ) if os . path . isdir ( file_path ) : main_directory = file_name new_main_directory = os . path . join ( new_output_dir , main_directory ) old_main_directory = os . path . join ( old_output_dir , main_directory ) diff = run ( [ \" git \" , \" diff \" , old_main_directory , new_main_directory ], capture_output = True ) . stdout . decode ( \" utf8 \" ) diff = diff . replace ( old_main_directory , \"\" ) . replace ( new_main_directory , \"\" ) print ( \" The following diff would be applied: \\n \" ) print ( diff ) print ( \"\" ) if not skip_apply_ask : update = \"\" while update . lower () not in ( \" y \" , \" n \" ) : update = input ( \" Apply diff and update [y/n]? \" ) # nosec if update . lower () == \" n \" : sys . exit ( \" User cancelled Cookiecutter template update. \" ) current_directory = os . getcwd () try : os . chdir ( expanded_dir ) run ( [ \" git \" , \" apply \" ], input = diff . encode ( \" utf8 \" )) cruft_state [ \" commit \" ] = last_commit cruft_state [ \" context \" ] = new_context with open ( cruft_file , \" w \" ) as cruft_output : json_dump ( cruft_state , cruft_output ) finally : os . chdir ( current_directory ) return True","title":"update"},{"location":"reference/cruft/cli/","text":"Module cruft.cli This module defines CLI interaction when using cruft . This is powered by hug which means unless necessary it should maintain 1:1 compatibility with the programmatic API definition in the API module cruft create : Expands the specified Cookiecutter template on disk. cruft update : Attempts to updates an expanded Cookiecutter template to the latest version. View Source \"\"\"This module defines CLI interaction when using `cruft`. This is powered by [hug](https://github.com/hugapi/hug) which means unless necessary it should maintain 1:1 compatibility with the programmatic API definition in the [API module](/reference/cruft/api) - `cruft create`: Expands the specified Cookiecutter template on disk. - `cruft update`: Attempts to updates an expanded Cookiecutter template to the latest version. \"\"\" import sys import hug from cruft import api , logo def _check_command_output ( up_to_date : bool ) -> None : if not up_to_date : sys . exit ( \"FAILURE: Project's cruft is out of date! Run `cruft update` to clean this mess up.\" ) else : print ( \"SUCCESS: Good work! Project's cruft is up to date and as clean as possible :).\" ) def _update_output ( updated : bool ) -> None : if not updated : print ( \"Nothing to do, project's cruft is already up to date!\" ) else : print ( \"Good work! Project's cruft has been updated and is as clean as possible!\" ) cli = hug . cli ( api = hug . API ( __name__ , doc = logo . ascii_art )) cli ( api . create ) cli . output ( _update_output )( api . update ) cli . output ( _check_command_output )( api . check ) Variables cli","title":"CLI"},{"location":"reference/cruft/cli/#module-cruftcli","text":"This module defines CLI interaction when using cruft . This is powered by hug which means unless necessary it should maintain 1:1 compatibility with the programmatic API definition in the API module cruft create : Expands the specified Cookiecutter template on disk. cruft update : Attempts to updates an expanded Cookiecutter template to the latest version. View Source \"\"\"This module defines CLI interaction when using `cruft`. This is powered by [hug](https://github.com/hugapi/hug) which means unless necessary it should maintain 1:1 compatibility with the programmatic API definition in the [API module](/reference/cruft/api) - `cruft create`: Expands the specified Cookiecutter template on disk. - `cruft update`: Attempts to updates an expanded Cookiecutter template to the latest version. \"\"\" import sys import hug from cruft import api , logo def _check_command_output ( up_to_date : bool ) -> None : if not up_to_date : sys . exit ( \"FAILURE: Project's cruft is out of date! Run `cruft update` to clean this mess up.\" ) else : print ( \"SUCCESS: Good work! Project's cruft is up to date and as clean as possible :).\" ) def _update_output ( updated : bool ) -> None : if not updated : print ( \"Nothing to do, project's cruft is already up to date!\" ) else : print ( \"Good work! Project's cruft has been updated and is as clean as possible!\" ) cli = hug . cli ( api = hug . API ( __name__ , doc = logo . ascii_art )) cli ( api . create ) cli . output ( _update_output )( api . update ) cli . output ( _check_command_output )( api . check )","title":"Module cruft.cli"},{"location":"reference/cruft/cli/#variables","text":"cli","title":"Variables"},{"location":"reference/cruft/exceptions/","text":"Module cruft.exceptions Contains all custom exceptions raised by cruft View Source \"\"\" Contains all custom exceptions raised by cruft \"\"\" class CruftError ( Exception ) : \"\"\" The base exception for any error originating from the cruft project \"\"\" class UnableToFindCookiecutterTemplate ( CruftError ) : \"\"\" Raised when Cruft is unable to find a cookiecutter template \"\"\" def __init__ ( self , directory ) : super () . __init__ ( self , f \" Was unable to locate a Cookiecutter template in `{directory}` ! \" ) self . directory = directory class NoCruftFound ( CruftError ) : \"\"\" Raised when no .cruft.json state is found in the current directory \"\"\" def __init__ ( self , directory ) : super () . __init__ ( self , f \" Was unable to locate a `.cruft.json` state file in `{directory}` ! \" ) self . directory = directory Classes CruftError class CruftError ( / , * args , ** kwargs ) The base exception for any error originating from the cruft project View Source class CruftError ( Exception ) : \"\"\" The base exception for any error originating from the cruft project \"\"\" Ancestors (in MRO) builtins.Exception builtins.BaseException Descendants cruft.exceptions.UnableToFindCookiecutterTemplate cruft.exceptions.NoCruftFound Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. NoCruftFound class NoCruftFound ( directory ) Raised when no .cruft.json state is found in the current directory View Source class NoCruftFound ( CruftError ): \"\"\"Raised when no .cruft.json state is found in the current directory\"\"\" def __init__ ( self , directory ): super (). __init__ ( self , f \"Was unable to locate a `.cruft.json` state file in `{directory}` !\" ) self . directory = directory Ancestors (in MRO) cruft.exceptions.CruftError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. UnableToFindCookiecutterTemplate class UnableToFindCookiecutterTemplate ( directory ) Raised when Cruft is unable to find a cookiecutter template View Source class UnableToFindCookiecutterTemplate ( CruftError ): \"\"\"Raised when Cruft is unable to find a cookiecutter template\"\"\" def __init__ ( self , directory ): super (). __init__ ( self , f \"Was unable to locate a Cookiecutter template in `{directory}` !\" ) self . directory = directory Ancestors (in MRO) cruft.exceptions.CruftError builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Exceptions"},{"location":"reference/cruft/exceptions/#module-cruftexceptions","text":"Contains all custom exceptions raised by cruft View Source \"\"\" Contains all custom exceptions raised by cruft \"\"\" class CruftError ( Exception ) : \"\"\" The base exception for any error originating from the cruft project \"\"\" class UnableToFindCookiecutterTemplate ( CruftError ) : \"\"\" Raised when Cruft is unable to find a cookiecutter template \"\"\" def __init__ ( self , directory ) : super () . __init__ ( self , f \" Was unable to locate a Cookiecutter template in `{directory}` ! \" ) self . directory = directory class NoCruftFound ( CruftError ) : \"\"\" Raised when no .cruft.json state is found in the current directory \"\"\" def __init__ ( self , directory ) : super () . __init__ ( self , f \" Was unable to locate a `.cruft.json` state file in `{directory}` ! \" ) self . directory = directory","title":"Module cruft.exceptions"},{"location":"reference/cruft/exceptions/#classes","text":"","title":"Classes"},{"location":"reference/cruft/exceptions/#crufterror","text":"class CruftError ( / , * args , ** kwargs ) The base exception for any error originating from the cruft project View Source class CruftError ( Exception ) : \"\"\" The base exception for any error originating from the cruft project \"\"\"","title":"CruftError"},{"location":"reference/cruft/exceptions/#ancestors-in-mro","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/cruft/exceptions/#descendants","text":"cruft.exceptions.UnableToFindCookiecutterTemplate cruft.exceptions.NoCruftFound","title":"Descendants"},{"location":"reference/cruft/exceptions/#class-variables","text":"args","title":"Class variables"},{"location":"reference/cruft/exceptions/#methods","text":"","title":"Methods"},{"location":"reference/cruft/exceptions/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/cruft/exceptions/#nocruftfound","text":"class NoCruftFound ( directory ) Raised when no .cruft.json state is found in the current directory View Source class NoCruftFound ( CruftError ): \"\"\"Raised when no .cruft.json state is found in the current directory\"\"\" def __init__ ( self , directory ): super (). __init__ ( self , f \"Was unable to locate a `.cruft.json` state file in `{directory}` !\" ) self . directory = directory","title":"NoCruftFound"},{"location":"reference/cruft/exceptions/#ancestors-in-mro_1","text":"cruft.exceptions.CruftError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/cruft/exceptions/#class-variables_1","text":"args","title":"Class variables"},{"location":"reference/cruft/exceptions/#methods_1","text":"","title":"Methods"},{"location":"reference/cruft/exceptions/#with_traceback_1","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/cruft/exceptions/#unabletofindcookiecuttertemplate","text":"class UnableToFindCookiecutterTemplate ( directory ) Raised when Cruft is unable to find a cookiecutter template View Source class UnableToFindCookiecutterTemplate ( CruftError ): \"\"\"Raised when Cruft is unable to find a cookiecutter template\"\"\" def __init__ ( self , directory ): super (). __init__ ( self , f \"Was unable to locate a Cookiecutter template in `{directory}` !\" ) self . directory = directory","title":"UnableToFindCookiecutterTemplate"},{"location":"reference/cruft/exceptions/#ancestors-in-mro_2","text":"cruft.exceptions.CruftError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/cruft/exceptions/#class-variables_2","text":"args","title":"Class variables"},{"location":"reference/cruft/exceptions/#methods_2","text":"","title":"Methods"},{"location":"reference/cruft/exceptions/#with_traceback_2","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/cruft/logo/","text":"Module cruft.logo View Source from cruft._version import __version__ ascii_art = rf \"\"\" __________________________________________________/ \\\\\\\\ \\_______________ ________________________________________________/ \\\\ \\///________________ _______________________________________________/ \\\\ \\__________/ \\\\ \\______ _____/ \\\\\\\\\\\\\\\\ __/ \\\\ / \\\\\\\\\\\\ \\___/ \\\\ \\____/ \\\\ \\__/ \\\\\\\\\\\\\\\\ \\____/ \\\\\\\\\\\\\\\\\\\\ \\_ ___/ \\\\ \\//////__\\/ \\\\ \\///// \\\\ \\_\\/ \\\\ \\___\\/ \\\\ \\_\\//// \\\\ \\//____\\//// \\\\ \\////__ __/ \\\\ \\_________\\/ \\\\ \\___\\///__\\/ \\\\ \\___\\/ \\\\ \\____\\/ \\\\ \\_________\\/ \\\\ \\______ _\\// \\\\ \\________\\/ \\\\ \\_________\\/ \\\\ \\___\\/ \\\\ \\____\\/ \\\\ \\_________\\/ \\\\ \\_/ \\\\ __ __\\/// \\\\\\\\\\\\\\\\ _\\/ \\\\ \\_________\\// \\\\\\\\\\\\\\\\ \\_____\\/ \\\\ \\_________\\// \\\\\\\\ \\___ ____\\////////__\\///___________\\/////////______\\///___________\\/////____ If you need the boilerplate, at least let cruft manage it. Version: {__version__} Copyright Timothy Edmund Crosley 2019 MIT License \"\"\" Variables ascii_art","title":"Logo"},{"location":"reference/cruft/logo/#module-cruftlogo","text":"View Source from cruft._version import __version__ ascii_art = rf \"\"\" __________________________________________________/ \\\\\\\\ \\_______________ ________________________________________________/ \\\\ \\///________________ _______________________________________________/ \\\\ \\__________/ \\\\ \\______ _____/ \\\\\\\\\\\\\\\\ __/ \\\\ / \\\\\\\\\\\\ \\___/ \\\\ \\____/ \\\\ \\__/ \\\\\\\\\\\\\\\\ \\____/ \\\\\\\\\\\\\\\\\\\\ \\_ ___/ \\\\ \\//////__\\/ \\\\ \\///// \\\\ \\_\\/ \\\\ \\___\\/ \\\\ \\_\\//// \\\\ \\//____\\//// \\\\ \\////__ __/ \\\\ \\_________\\/ \\\\ \\___\\///__\\/ \\\\ \\___\\/ \\\\ \\____\\/ \\\\ \\_________\\/ \\\\ \\______ _\\// \\\\ \\________\\/ \\\\ \\_________\\/ \\\\ \\___\\/ \\\\ \\____\\/ \\\\ \\_________\\/ \\\\ \\_/ \\\\ __ __\\/// \\\\\\\\\\\\\\\\ _\\/ \\\\ \\_________\\// \\\\\\\\\\\\\\\\ \\_____\\/ \\\\ \\_________\\// \\\\\\\\ \\___ ____\\////////__\\///___________\\/////////______\\///___________\\/////____ If you need the boilerplate, at least let cruft manage it. Version: {__version__} Copyright Timothy Edmund Crosley 2019 MIT License \"\"\"","title":"Module cruft.logo"},{"location":"reference/cruft/logo/#variables","text":"ascii_art","title":"Variables"}]}